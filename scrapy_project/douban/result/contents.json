[
{"url": "https://www.douban.com/note/742495363/", "title": "8个数据清洗Python代码，复制可用，最长11行 | 资源", "article": "数据清洗，是进行数据分析和使用数据训练模型的必经之路，也是最耗费数据科学家/程序员精力的地方。\n这些用于数据清洗的代码有两个优点：一是由函数编写而成，不用改参数就可以直接使用。二是非常简单，加上注释最长的也不过11行。\n在介绍每一段代码时，都给出了用途，也在代码中也给出注释。\n大家可以把这篇文章收藏起来，当做工具箱使用。\n涵盖8大场景的数据清洗代码\n这些数据清洗代码，一共涵盖8个场景，分别是：\n删除多列、更改数据类型、将分类变量转换为数字变量、检查缺失数据、删除列中的字符串、删除列中的空格、用字符串连接两列（带条件）、转换时间戳（从字符串到日期时间格式）\n删除多列\n在进行数据分析时，并非所有的列都有用，用df.drop可以方便地删除你指定的列。\n\n\n转换数据类型\n当数据集变大时，需要转换数据类型来节省内存。\n\n\n将分类变量转换为数值变量\n一些机器学习模型要求变量采用数值格式。这需要先将分类变量转换为数值变量。同时，你也可以保留分类变量，以便进行数据可视化。\n\n\n检查缺失数据\n如果你要检查每列缺失数据的数量，使用下列代码是最快的方法。可以让你更好地了解哪些列缺失的数据更多，从而确定怎么进行下一步的数据清洗和分析操作。\n\n\n删除列中的字符串\n有时候，会有新的字符或者其他奇怪的符号出现在字符串列中，这可以使用df[‘col_1’].replace很简单地把它们处理掉。\n\n\n删除列中的空格\n数据混乱的时候，什么情况都有可能发生。字符串开头经常会有一些空格。在删除列中字符串开头的空格时，下面的代码非常有用。\n\n\n用字符串连接两列（带条件）\n当你想要有条件地用字符串将两列连接在一起时，这段代码很有帮助。比如，你可以在第一列结尾处设定某些字母，然后用它们与第二列连接在一起。\n根据需要，结尾处的字母也可以在连接完成后删除。\n转换时间戳（从字符串到日期时间格式）\n在处理时间序列数据时，我们很可能会遇到字符串格式的时间戳列。\n这意味着要将字符串格式转换为日期时间格式(或者其他根据我们的需求指定的格式) ，以便对数据进行有意义的分析。\n 对Python感兴趣或者是正在学习的小伙伴，可以加入我们的python学习者聚集地，看看前辈们是如何学习的！从基础的python脚本到web开发、爬虫、django、数据挖掘等，零基础到项目实战的资料都有整理。送给每一位python的小伙伴！每天都有大牛定时讲解Python技术，分享一些学习的方法和需要注意的小细节，现在，点击加入我们的 \npython学习者聚集地\n 吧"},
{"url": "https://www.douban.com/note/741919025/", "title": "alx. 19007 零基础初学python：超省工夫的学习方法推荐", "article": "2019年11月14日。\n为什么突然想学python呢？\n外部压力来自于，在朋友圈常见一些“3岁学编程”的转发，每每看见都让人感叹，小娃娃兴趣班都这么高科技了。\n内部压力来自于，自己也整天用表格结构和一些简单的函数，作为一个总在（盲目）追求高效率和标准化的人，我觉得未来的趋势是会淘汰我们这些只会用表格的人，就像office和英语逐渐淘汰了上一代，编程的门槛也会逐渐淘汰我们只会用office的这一代。\n经过一番搜索，我先后试验了2种不同的python入门学习方法（都还没结束）。\n一种是通过鸡胡网上搜到的【Python简明教程】PDF版本，据说是一个广而传播的有名教材。\n然后我边看教材边学。\n好累，只看了1/4左右。\n另一种是coursera上的课程Programming for Everybody。\n意外地简单明了！\n用coursera学习python有3个优势：\n优势一是用视频学习比上一种的看文本教材自学的理解速度要快，因为语音+图像的传播的效果和纯文字传播的效果相比，前者确实让人更好理解和更快接受。\n优势二是视频学习能包含动态讲解，虽然视频是事先录制好的，但是它已经包含讲师事先制作的一个简要的流程图，以及用电笔在流程图上指指画画、边画边讲，顺手就解开很多疑惑，如果是用文本式的教材，不知道得多费多少工夫才能表达出来。（这个也要看视频教程的本身的制作是否足够细致以及讲师是否细心，我觉得coursera这个课程就非常的细。）\n优势三是python本来就是用的英文基础，包含很多英语单词的缩写，所以里面很多术语用直接用英文解释就很好理解，例如str这个一看就是string，中文的话翻译成字符串，然后还得倒过来背“str是字符串，字符串是str”，如果有英文基础的话那就省了一大层工夫了。再例如\\n是增加一行空白行，看中文教材的时候要去记住“\\n是增加一行空白行，n代表一段空白行”，看英文视频教材只说一遍就理解了，n就是new line嘛！\n用coursera学习有2个门槛，一个是英语。虽然coursera也有中文翻译，但是视频原版是英文的，你顶多看个中文字幕，这样一转折，学习速度和质量都会下降，就没必要了。另一个是要科学上网，因为不科学地打开coursera实在太难了。\n如果实在打不开coursera，建议找国内的慕课网来看视频学习吧。\n学习效率来说（仅针对python），英文版视频 > 中文版视频 > 文字教材\n现在我已经看完了programming for everybody，主要就是讲python本身是如何“思考”、如何输出结果的，和一些基础function。目前在看同系列的第二课，Data Structures。这些东西都是以前我光看标题就觉得头大和复杂，但是（得益于课程讲的特别好）学习跟下来发现真的不难鸭。\n90后的朋友们，我们可以的。"},
{"url": "https://www.douban.com/note/658771308/", "title": "Python一天速成", "article": "0 \n前几天看了这条豆瓣广播，真心觉得齁甜好厉害。\n在下方的评论里看到这种图叫诺力图，打开百度准备找地方下载。然而发现这只是个表达方式，并没有 nolli地图全球高清版.pdf 这种东西。\n但是阴差阳错找到了几篇文章，于是试着自己动手。\nHow to create a Nolli Map 10 minutes\n （这个方法生成的有点鬼畜）\n我把城市“压扁”后，回忆扑面而来\n[python]如何生成城市诺力图\n1 安装Anaconda & OSMNX\n首先下载Anaconda \n（链接）\n，我用的是Windows的，安装包500+M。\n右键管理员身份运行安装。安装完成后，管理员身份运行Anaconda Prompt。\n管理员权限运行Anaconda Prompt\n打开Anaconda Prompt后的界面\n接着输入  \nconda install -c conda-forge osmnx\n系统会检查环境和更新，接着屏幕会提示《输入y或n》更新里面的packages. \n输入y，等待下载完成。\n输入\nconda list\n就可以看到osmnx已经安装好了。\n2 Python速成\n还是在那个黑黑的界面，输入 \npython\n出现 >>> 就是进入python环境了。\n>>>\n接着输入：\nimport osmnx as ox\nfrom IPython.display import Image\nox.config(log_file='./log',log_console=True,use_cache=True)\nimage_folder='./img'\nextention='png'\nsize=400\nplace='xuanwuhu'#图形文件的名字\npoint=(32.0741656400,118.7881417600)#经纬度坐标，我在\n这里\n 复制的，用的谷歌地球的经纬度坐标\ngif,ax=ox.plot_figure_ground(point=point,filename=place,network_type='all',dpi=150)\nImage('{}/{}.{}'.format(image_folder,place,extention),height=size,width=size)\n图片存好了\n3 找图片\n图片要么是在C:windows->system32->images下面，\n要么是C:用户->(用户名)->images下面。\n或者直接搜索也可以，文件名见上面代码备注1那行。\n上述代码生成的玄武湖\n地图上的玄武湖\n是不是 很厉害\n4 P图\n剩下的就是用各种美图软件裁剪、P图、配文字等等。SO Easy啦\n*真的是一天速成（其中半天尝试了错误的方法），其实比较烦的就是下载的等待时间。\n**不是技术宅，进一步的也就不会了\n***如果要更改地图的视野，可以在point=point, 后面加上dist=(一个数值)，比如dist=2000的时候上图的效果就是这样。实际数值要根据输出效果调整啦，不过视野越大，耗时越长，画出来就更乱\n #2018年2月27日19:36:28 \n其他个性化的参数 可以参考\n链接"},
{"url": "https://www.douban.com/note/744124010/", "title": "5000字干货总结，python社招面试经验分享", "article": "即使是临近年末，我依然选择了裸辞，冒着可能会失业的风险。\n我之前是在深圳工作的，因为自己是江苏人，也不想在深圳长期发展，所以先辞了职，回到上海这边好让自己更方便的参加面试。\n这是我第二次裸辞了，有了上一次的裸辞经验，我这一次在心理准备方面，明显更加的游刃有余。\n花了一周多一点的时间，在上海参加了十几家公司的面试，也包括美团、字节跳动等大厂，可是因为能力不够或技术栈不匹配被刷了。最终有三四家想要要我，我也拿到了一份较为满意的offer。\n面试是一个非常消耗心力的过程，我很难想象，若不是我比较侥幸，拿到了几个还满意的offer，我很难想象在此时凄风苦雨的寒冷的上海，孑然一身的我，会面临怎样的崩溃与绝望。\n所以，我衷心希望，我能够把自己的一些面试经验分享出来，去帮助到一些正在找工作的朋友，让他们的求职之路更顺利一些，少一点像我这样的折腾。\n我工作三年，主要编程语言是python，找的是后端开发或运维开发的岗位，想结合自己的实际面试经历，来谈一谈python社招的一些经验，欢迎大家交流讨论~\n面试之前\n市场环境\n先说一下大环境，中国的互联网环境已经渐趋稳定成熟了，但初中级别的程序员依然很泛滥，高级程序员很缺失。所以想要在众多应聘者中脱颖而出，实力才是王道。\n另外，通常的招聘季是金三银四或者金九银十，像我这个11月份去找工作的毕竟是很少了，但我觉得上海毕竟是大城市，要说市场上没有岗位是不可能的，另外在淡季，和我竞争的人也很少了。所以，基于以上的判断以及自己的勇气，我毅然觉得辞职，从深圳来到了上海。\n个人定位\n我觉得，每一个招聘者都要对自己在市场上的位置做一个合理的评估，这样才能准确的知道自己想要找什么类型的公司，是大公司大平台呢，还是中小型企业呢，还是创业公司呢？评估的依据，取决于自己的实力，职业道路的方向，以及对市场的认识。\n不过如果不清楚也没有关系，投递公司的时候可以各类公司都投一投，大中小公司都去面一面，总之，不要把鸡蛋放在一个篮子里，多给自己制造一些机会。面试是一个很好的去接触外界，了解自己能力水平的过程，可以帮助你对市场环境有一个更清晰的认识。面试结束后通常有反问问题的环节，也可以把握住机会，多去问一问对方公司在做的东西，使用的技术栈等等。\n对于我自己来说，我就把面试当成一个很好的检验自己的机会，同时让我有机会去和别的公司交流技术。所以说，平时在工作过程中，也可以隔三差五的出去面试一下，看看自己的能力水平几何，避免自己和市场脱节太久，以及温水煮青蛙的情况。\n简历\n接下来就是制作一份简历，关于如何制作一份简历，网络上的教程也很多了。我觉得技术简历的关键就是要把自己的做的比较出彩的项目，以及个人技术栈讲清楚，这些都是面试中问的比较频繁的几个点。另外因为自己痴迷于markdown，第一次尝试了markdown风格的简历，效果还不错，蛮清晰的。\n渠道\n对于招聘渠道的选择，如果有小伙伴的内推那是最好的，另外建议多注册几个app，多管齐下的去寻找面试机会，比如拉勾、boss直聘、猎聘等等。一些想去的公司的官网的招聘页，也是一个不错的信息来源。\n面试准备\n作为技术面试，该如何去复习准备面试呢，我觉得可以从以下几点去考虑。\n数据结构与算法\n为什么把这一块放在第一个讲，因为这是技术面试里非常重要，但是平时工作中又最容易忽视的一块。都说「面试造航母，工作拧螺丝」，如果不是算法岗，程序员在日常工作中算法使用场景非常有限，但这就是面试考察的一个重点。\n我大概面了十几家公司，基本每家公司都会考一些算法题，或者让你说一下思路，或者直接手写程序，如果没有事先准备过，会特别的不适应，尤其是白板算法那块。\n所以，我的准备建议是，面试前至少前一周，就要花时间去练习算法题，保持手感了。\n首先强推leetcode网站，中文站是\nhttps://leetcode-cn.com/\n。leetcode是非常有名的刷题网站，里面汇聚了各大企业的经典算法题，而且可以在线提交代码，自定义测试用例，查看其他人的题解等等。如果你觉得中文站上面的题解没有自己想要的，也可以看一下外文站\nhttps://leetcode.com/\n\n，他们的题目顺序都是一样的，只是中文站在本土化这方面更强一点。\n如果因为时间紧迫，我建议你针对以下数据结构和算法的知识点进行重点复习：\n各种排序算法，冒泡排序，堆排序，快速排序等，时间复杂度空间复杂度分析，能做到手写。\n常用数据结构。链表、二叉树、堆、栈等等。\n经典算法题。（待整理）\n基础知识\n任何一门技术面试，基础知识一定是重中之重。对于python程序员面试来说，我觉得下面三块内容比较重要，考察的频率也非常高。\n1. 语言基础\n可变对象、不可变对象、装饰器、迭代器和生成器、线程和进程、魔术方法、动态解释性、元类等\n2. web基础\nhttp请求、状态码、网络安全、django处理请求的顺序、cookie和session\n3. 数据库\nmysql的事务、索引、锁、性能调优，nosql数据库中redis考察的比较多。\n项目经验\n一般对应届生来说，基础知识很重要。对于社招来说，项目经验是非常重要的一块内容。\n我建议可以从下面几个角度去准备自己的项目：\n1. 项目介绍\n推荐STAR模型。\nS——situation，项目是什么背景下产生的\nT——task，你的任务是什么\nA——action，你怎么做的\nR——result，结果如何\n2. 项目中的难点、闪光点\n我相信每一个真实做过自己的项目的人，肯定会对自己的项目有所思考。总结一下自己在这个项目里最难的地方，以及最精彩的地方，也可以使用上面的STAR模型。\n3. 项目框架\n有的面试官会要求你在白纸上把项目的框架图或者设计图画出来，这个也可以提前准备下，做到条理清晰，临场画的话很容易乱。\n总结\n面试是一场艰难的战役，我发现在那种紧张对弈的交锋氛围中，我从来没有体会过所谓超常发挥的感觉，准备了100分，能把60分发挥出来就已经非常不错了。所以，建议每一个面试者都要提前把一些必问的东西（个人介绍、项目经验等等）提前准备好，并且模拟表达一下，以防临场紧张而忘词。\n面试真题\n因为自己大厂和创业公司都会去面，给我的感觉是，大厂的考察深度会更深一点，比如问你怎么用python定位一些内存满、CPU满的问题，怎么做mysql性能优化等等。而小公司问的更多是一些基础问题，以及看你之前经验的一个匹配度。\n我这里从我亲身的面试经历，精选出了30道面试常考题，涉及到了python面试的方方面面，大家可以自行测试。\npython基础\npython是什么样的语言，和其他语言的区别。\npython中的线程和进程，以及使用场景，你知道协程吗？\nGIL是什么，为什么会有GIL，去掉会怎样，有了GIL为什么还要给程序加锁？\n迭代器、可迭代对象、生成器分别是什么？生成器的作用和使用场景？\npython中的装饰器是什么？如何实现？使用场景？\npython中的元类是什么？\npython中的可变对象和不可变对象之间的区别。\npython的魔术方法你知道哪些，\nnew\n，\ninit\n，\ncall\n的区别是什么\ndjango的中间件是什么\ncelery的原理，如何配置worker的权重\n项目\n如何定位内存过高或CPU过高的问题\n画一下你的项目的结构\n项目中你遇到的最大的困难是什么，是如何解决的？\n项目中你最有成就感的地方是什么？\n你业余是怎么学习编程的？看哪些书？有自己做过什么项目？\nweb\nHTTP/GET/POST/PUT/PATCH之间的区别\n状态码的含义以及出现场景，301，302，404，500，502，504等\ncookie和session的区别和联系\n从url请求到返回，中间经历了什么\nHTTP和HTTPS的区别，HTTPS如何进行加密的\n数据库\nmysql的索引是什么，如何建立索引，B+树的结构\nmysql中的事务是什么，隔离等级是什么\n如何优化sql语句\nmysql的性能优化等\n操作系统\n堆和栈的区别\n什么是io多路复用\nnginx的配置\n算法\n找到整数列表的最大k个数，时间复杂度\n输入一维数组array和n，找出和值为n的任意两个元素\n常见的排序算法，时间复杂度分析\n生成一个旋转矩阵\n职业发展\n作为一个代码打工仔，对于我来说，想要成为牛逼的程序员的路还很长，一刻都不能懈怠。\n我无法从HR角度，或者技术leader的角度来臆测哪种状态的面试更能获取面试官青睐。但通过我积攒的大量的面试经验，我多少可以推断一些成为有竞争力的程序员的一些必要条件。\n1. 技术是王道\n这一点毋庸置疑。我是一个非科班出身的程序员，在技术成长方面更多的是在工作中学，但这还远远不够，每一位想要成为大牛的程序员，都必须深入底层原理去学习，比如操作系统、网络、数据结构和算法等，也许这些东西在你工作中看起来没用，却是提高你的技术深度，扩大技术视野的非常重要的一环。\n我是一个比较容易自卑的人，在面试的时候，遇到答不上来的问题还是非常容易挫败的，觉得自己好弱。术业有专攻是一方面，但很多基础的东西是一个程序员的基本素养，在这上面丢分还是很容易给面试官造成一个不好的印象的。另外，面试所覆盖的点也不一定完全击中你所准备的东西，我觉得面试者可以在面试过程中主动「推销」自己，哪怕一个问题没答上来，也要尽可能的展现一下自己在这一块内容里做过哪些研究，避免面试官错误预估你的水平。\n除了基础知识和底层原理，技术的另一块内容就是你在工作中的实践了。我在工作中常常见到一类人，他们只满足于被分配的任务，抱着多一事不如少一事的观念，不去把一个问题深入的去弄明白，害怕技术挑战，包括我自己曾经也是这一类人。\n其实这样对职业发展的道路是非常不好的，如果不去走出舒适区，你永远只是一个CURD的程序员，完全没有市场竞争力。在面试中最能展现自己的，就是你在面对技术难题的时候，是如何研究，如何思考，如何解决的。所以，工作中遇到技术难题，一定要把它当做技术上的试金石，成长的宝贵的机会，而不要当做拦路虎而逃避。\n2. 工作经历\n面试官常会问的一个问题是，你未来的职业规划是什么。我不知道其他人有没有清晰的规划，对我自己来讲，更多的还是走一步看一步，并没有想的特别远，这其实是很不好的。\n曾经有一个面试官对我讲，5年是一个关键节点，如果你工作5年，依然没有华丽的工作履历，或者工作能力仍旧处于小白水平的话，是非常危险的，市场对你的能力是由怀疑的。\n我想，如果作为一个5年开发经验的人，他差不多也换了两三份工作了吧，从每一个公司的情况每一个工作岗位的内容，多少可以看出点他的职业发展路径有没有一条清晰的路线。如果一个人的目标很明确，他的每次跳槽一定有自己的内在逻辑在里面，他的技术成长也不会太差。而如果每次跳槽都很盲目，技术成长没有延续性，很可能你虽然工作很多年，但是根本没有核心的技术竞争力，这是要警惕的。\n对未来的规划这块内容，我自己也非常欠缺，因为我总是抱着要「活出自我」的想法，对一些世俗理论天然排斥，其实是走了很多弯路的，不过既然我意识到了这一点，亡羊补牢为时未晚吧，未来，会多接触一些技术大牛，参加一些技术论坛，不会囿于自己的舒适区，早点找到一条快速的职业发展路径。\n薛兆丰老师曾经讲过一句话，「每个人都在为自己的简历打工」，我在这里感同身受，卖方只是提供工作岗位的，竞争永远是买方和买方之间的竞争。所以，想要出人头地，一定要比其他员工多下功夫，少壮不努力，老大徒伤悲。\n3. 格局\n这个词是我从一个猎头朋友那儿听到的，他说在职场中，男生最重要的是格局。\n我是这么理解的，只有你愿意到达什么样的高度，你才有可能成为什么样的高度的人。比如，如果你只甘心做一个工程师，那就活该当一个底层码农了，而如果你能够站在更高的维度去做一些事情，我相信你能收获很多宝贵的东西。\n比如，在实际开发中，多去把一些业内的新技术引用进来，而不是仅仅满足于已经成熟的开发框架；不再仅仅去完成领导分配的任务，多站在公司或者团队的视角去看问题，多一些全局的视野；遇到问题时，不要简简单单的解决了就完事了，要学会深入底层，以及触类旁通，把这一类问题都解决，形成自己的思考问题的逻辑框架……\n这些东西也是我在此前的工作中缺失的，我希望我自己能够在新的工作中，多思考，多沉淀，形成自己的技术格局。 毕竟也不是初入职场的小白了，我理当给自己提出更高的要求，这也是为了在下一次的招聘过程中，能更顺利一些。\n每次拿到offer之后，总会长舒一口气，觉得自己可以休息一下了。但随之而来的是，后面的入职、适应新的工作、新的工作团队，搬家找房，一个又一个的挑战接踵而至。\n还不能懈怠啊，希望自己在二十一世纪一十年代能安稳下来，以最好的姿态去迎接2020年！也祝所有在找工作的朋友们早日拿到满意的offer。\n最后，我建了一个github的项目，上面会持续更新我的python学习心得和面试指导，欢迎star~\nhttps://github.com/ZhiyuSun/python-interview"},
{"url": "https://www.douban.com/note/557708863/", "title": "参考书单: 零基础 Python 入门", "article": "我曾经提及自己是文科生转码农，到现在为止，写了一年半的 Python。这其中的艰辛大概只有我自己清楚，当然收获还是极多的。除了师傅教得好，我也读了不少 Python 的入门书籍，在此推荐一番。\n\n1. \nLearn Python the Hard Way\n没错，我也不能免俗，读过这本书。不过这本书比较强调动手，原理什么的讲得很浅。如果你动手能力很强，拿这本书入门不错。\nLearn Python the Hard Way\n8.4\nZed A. Shaw / 2013 / Addison-Wesley Professional\n\n\n2. \nLearning Python\n\n\n 因为觉得第一本书太浅显，我就找了这本书。没错，原装是厚厚的上下两本。各个章节讲得极其详尽，所以这本书似乎又走向了另一个极端，令人略感啰嗦。反正我是没看完。\nLearning Python\n8.2\nMark Lutz / 2009 / O'Reilly Media\n\n3. \nBeginning Python\n\n\n因为对上面这两本书不太满意，所以我又找了一本书。这本介于上面两本之间，不是很浅显，也不是很啰嗦。可惜这本书最大的问题在于，没有习题！\nBeginning Python\n8.8\nMagnus Lie Hetland / 2005 / Apress\n\n4. \nCore Python Programming (2nd)\n\n就在我行将绝望之时，我师傅推荐了这本书给我。没错，是第二版，不是最新的第三版。这本书详略得当，又附有丰富的习题，非常适合当时零基础的我。\nCore Python Programming\n8.0\nWesley J. Chun / 2006 / Prentice Hall PTR\n\n\n5. \nEffective Python\n\n在我慢慢入门之后，我又开始读这本进阶版的 Python 教程。作者 Brett Slatkin 是一位 Googler，非常有经验。这本书让我养成了一些 Python 的 best practice。\nEffective Python\n8.5\nBrett Slatkin / 2015 / Addison-Wesley Professional\n\n6. \nPython Cookbook\n\n我的桌边一直摆着这本书，时不时地可以翻翻。它是基于 Python 3.0 写的，很多内容更加具有参考价值。\nPython Cookbook\n8.6\nAlex Martelli Anna Ravenscroft David Ascher / 2010 / 人民邮电出版社\n\n\n7. \nData Structures and Algorithm in Python\n\n作为非科班出身的程序员，数据结构一直都是我的短板。当时在亚马逊中国上捡漏捡到这本，一直缓慢地再啃，很不要脸的是，到现在都没啃完。\nData Structures and Algorithms in P\n9.5\nMichael T. Goodrich Roberto Tamassia Michael H. Goldwasser / 2013 / John Wiley & Sons\n\n\n8. \nHigh Performance Python\n\n\n这本是正在翻的 Python 书，希望自己的 Python能更上一个台阶。\nHigh Performance Python\n评价人数不足\nAndrew Lewis / 2010 / O'Reilly Media, Inc.\n9. \nWriting Idiomatic Python 3.3\n \n\n之前翻到过作者的 blog，仔细看了下，还是很有料的。\nWriting Idiomatic Python 3.3\n评价人数不足\nKnupp, Jeff\n\n\n综上而言，最最推荐的 Python 入门书就是 Core Python Programming 的第二版。\n如果你的 Python 已经入门了，不妨考虑试试 pandas：\n做数据分析，你怎么能不用 pandas 这个神器？"},
{"url": "https://www.douban.com/note/543082723/", "title": "人生苦短，只需一部Python简史", "article": "作者：Vamei，严禁转载。\n\nPython语言的标志\n\nPython是我喜欢的语言，简洁、优美、容易使用。前两天，我很激昂的向朋友宣传Python的好处。\n“好吧，我承认Python不错，但它为什么叫Python呢？”\n“呃，似乎是一个电视剧的名字。”\n“那你说的Guido是美国人么？”\n“他从Google换到Dropbox工作，但他的名字像是荷兰人的。”\n“你确定你很熟悉Python吗？”\n所以为了雪耻，我花时间调查了Python的历史。我看到了Python的设计初衷，看到了Python成功的时代背景，看到了一门编程语言的演化历史。我也看到了Python与开源运动的奇妙联系，一窥开源开发的理念和成就。\n\n1. 起源\nPython的作者，Guido van Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。\nGuido van Rossum\n\n在那个时候，Guido接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。当时所有编译器的核心是做优化，以便让程序能够运行。为了增进效率，编程语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的代码。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会瘫痪你的电脑。\n\n这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。\n\nGuido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。ABC语言使用冒号和缩进来表示程序块。行尾没有分号。for和if结构中也没有括号()。赋值采用的是PUT，而不是更常见的等号。HOW TO用于定义一个函数。这些改动让ABC程序读起来像一段文字。\n\n尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：\n\n1) 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。\n\n2) 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？\n\n3) 过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。\n\n4) 传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。\n\n1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python's Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的实验性探索\nMonty Python's Flying Circus\n。\n\n2. 一门语言的诞生\n1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。\n\nPython语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。\n\nPython从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。\n\n最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。\n人生苦短，我用python\n\n3. 时势造英雄\n我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性  ，比如图形化界面。\nWindows 3.0\n\n由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。\n\n另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。\n\n硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。\n\nPython被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。\n\n到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。\n\n4. 启示录\nPython崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。\n\n在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是走捷径。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。\n\nPython从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。\n\n无论Python未来的命运如何，Python的历史已经是本很有趣的小说。"},
{"url": "https://www.douban.com/note/731945762/", "title": "我与python的十年（中）", "article": "14年的时候，只是知道了python基础用法，应该是时候好好研究下python的复杂用法了。而且一般复杂的用法，都会出现在优秀的开源框架里面，tornado首当其冲。当时有点初生牛犊的心态，一头扎入tornado的代码，一开始的时候真的看的一脸懵，仅仅看懂了示例代码，源码根本无法理解。\n抱着跟学英语一样的方法，我看一遍不行 就看两遍三遍五遍反反复复，我记不住方法名 类名我就用印象笔记记录下来。可是这种方式只能说是静态分析，真正的执行结果是怎样的，静态的还是看不到具体的执行流程。所以就想着把代码调试起来了，但是之前都是面向log编程。\n针对大型非自己所写的项目，这种方式好像行不通。而且打点只能看到某一个时间点的执行，观看到的是某些变量的运行值，还是比较片面。如果要全面的看，只能动态调试，经过一番翻阅资料，了解pdb这个调试库，了解了它的相关使用方法，单步调试，查看堆栈，打印变量，添加断点这些都搞明白了，就顺便画了一章流程图出来。\n13-15年其实都是写几百行的python脚本，也就是几个文件。基本都是一些工具类的拼装代码，觉得没什么长进。就开始了一些python虚拟机的学习，泡社区发现了一本书，著名的《python源码剖析》而且经常逛当时很有名的我记得应该是是叫啄木鸟社区华莽用户组。\n当时作为一个python小白闲逛，默默的看大神们的帖子，如饥似渴的汲取知识。看到书就去搜索下载，去看去记录总结。也会去参加过一个python的线下的沙龙活动，当时是第一次参加沙龙活动。活动中知道了python里面几个有名的人，现在都不太活跃了。\n当我写这篇文章的时候这本书已经绝版多年了，搜索了下孔夫子旧书网都是200+以上的价格，足见这本书的珍贵性，我当时下载的pdf版本，看了放下，过一阵子又拿出来看反反复复，总是没有看的下去。\n因为功力问题，c语言基础差很多东西不太懂。例如：链表、函数指针，hash，但是当时也做了一些自己的总结，如上图。现在经过了这么多年的熏陶，可以手写大几百行的纯cwebsocket server，也可以照着rust搞一个c++ftp的客户端，了解了hash的原理。\n而且读了比如csapp、《ruby on microscope》等基础类的书籍。了解基于stack 的virtual machine的一些设计原理，现阶段看起这本书来会顺畅很多。不会觉得茫然无措，而是会有那么一种柳暗花明又一村的感觉。也想利用好业余时间仔细通读一下当年的这本好书，做做总结后续也想给大家做一个分享。\n16年到18年这段时间，其实并没没有花费过多的学习时间在python上。主要还是因为基本的语法都已经ok了，一般的需求容易用python搞定。精力更多的都放在了学习linux kernel 还有看经典的计算机书籍上面。\n这个阶段因为工作需要也用tornado、bottle这两个短小精悍的web框架写用于连接es搜索系统。python编码能力随着时间的迁移越来越精进，也比较注重代码的规范性，去阅读了谷歌的python的命名规范，尽可能的去靠拢。也会用到一些python里面独有的语法糖。想起来刚开始学习编程的时候写出来的变量方法命名都很随意，现在觉得都那么丑。\n英文文档的阅读能力经过学习也有所积累，可以慢慢的去看一些python的官方manual还有pep，当我去看它的pep的一些章节，比如讲generator的一些设计原则以及讲到lazy computing，还是会有一些特别体会的，会了解到一些python的语法设计的初衷以及原理。后续会单独的讲一讲，如何去看python的pep。\n一如既往的未完待续。。。。。。"},
{"url": "https://www.douban.com/note/747934265/", "title": "由BASIC到Python", "article": "昨天，闲来无事，看《跟老齐学Python，从入门到精通》，在笔记本安装Python。\n说起来，我不算是零基础，也是计算机老鸟，虽然现在堕落到不会安装系统的窘境，但这辈子没少和计算机语言打交道。\n第一次学习计算机语言，大概距今已有三十八年。那是1982年，我大三，BASIC语言。\n这是当时非计算机专业理工科的公共计算机语言，必修课。感觉挺容易，工作后，才发觉有些误导，不如C语言更有教益。不过那时没有条件学其它语言，连FORTRAN也只能供计算机专业学习。学习计算机语言必须上机，当时DJS130，可能只有BASIC可用。\n工作后，自己大部分时间是系统集成工程师，没有专做程序员，可能是老肖识人慧眼。因此，我为服务于程序员，在计算机语言上可谓狗揽八摊屎，什么都摸一点，命令、汇编、SQL、FORTRAN、BASIC、C都碰了面，哪个也不精。从我自己的认知，大概不具备程序员的天份，所以也就安于写点小程序拉倒，大不了向系统分析员方向迈进，比程序员还高大上呢。\n当然，既然在这行当，难免赶鸭子上架，有时也写点代码。八十年代，参加工作，组里有一台PC1500，日本生产的袖珍计算机，只能跑BASIC。我要显摆一下，编写了一个日历，被尹副主任夸奖几句。又玩了一阵8086单板机，编写了一个源程序打印程序，用的是机器码！而且是从下午干到半夜三点，尹副主任又赏识一番，后来把我推荐到攀钢组。\n攀钢组我是系统集成工程师，主要是VAX/VMS DCL命令语言，写点测试程序。1988年，用MS BASIC，编写光纤传输系统的测试程序，测试误码率。可惜程序运行太慢，测不出10的—11次方量级，最后被同事的汇编语言测试程序所替代。1994年做实验，临时拿起C语言，那时是MFC5.0，凑合完成任务。之后，迷信了VB，曾用VB做过网管系统的一个演示界面原形，当然，没有拿出手，但起码是用VB，而不是用VISIO画的。2000年，自建网站，用了一段VBScript。说起来不少阅历，倒真没长进。\n从上述可以看出，本人与BASIC最有渊源。据说，Python与Visual Basic比较，更强大，用途广泛，更具跨平台，且开源本质意味着不可能为一家公司所掌控。\n“你以为的岁月静好，只不过是有人在替你负重前行。”"},
{"url": "https://www.douban.com/note/742842665/", "title": "如何让自己一直成为一个 Python 菜鸟？", "article": "是的，在这里我无法告诉你如何成为一个 Python 的骨灰级 “砖” 家，但是对于 “如何让自己一直成为一个 Python 菜鸟” 这一个话题，我想我还是可以跟你讨论讨论的。毕竟， 99% 的人一开始都是个菜鸟...\n   \n 众所周知（我想你的微信朋友圈不止一次收到过 Python 的广告哈哈哈哈）， Python是容易学，易上手的编程语言，就像官方说的一样，Python是一门强大又牛逼的编程语言。 \n 所以说，要让自己一直成为 Python 菜鸟还是有一丢丢难度的。 \n 不过办法总比困难多嘛，我这就给你支招。 \n 首先，你在网上学完了一些 \nPython 的基础语法\n（比如各种数据类型、运算符、条件循环语句...）之后，一定要骄傲起来，特别是自己能写一两个脚本的时候，一定要觉得自己牛逼，最好带点自负，走路要横着走的那种。\n\n一遇到问题就猛百度，或者把问题往各种群一顿猛砸，就不信没人帮忙解决，怕啥怕，要有 “人死X朝上” 的魄力。 \n 这样成为 Python 菜鸟第一步算是练成了，但是偶尔你的上进心会 “作祟”，觉得该让自己进步一些了。\n\n这时候一定要压抑住自己的想法，想要让自己一直成为 Python 菜鸟，是需要坚持的。\n\n\n官方文档\n，千万不要去看，因为这里面都是 Python 原汁原味的教程和一些说明，偷偷告诉你，很多人都不会去看官方文档的，得像他们一样，瞟都不能瞟一眼的。 \n Python 有个特点，就是第三方库特别多，通过它们能实现各种牛逼功能，拿来就用，能用第三方库搞定就不要自己写，比如牛逼的 requests、Flask库，一定不要去了解它为\n什么要这样实现，\n不要试图去看它的源码了解它的工\n作方式，\n因为一旦去学习第三方库的代码，离菜鸟又远了一步。 \n 什么 \nPythonic\n也不关菜鸟的事，对于一些诸如 lambda、装饰器、语法糖、列表生成式等玩意能不了解尽量别去了解，毕竟这些代码看起来有点装逼，不适合菜鸟（单压x1） \n 什么 \nPython 并发编程\n也不用管，什么多进程、多线程、协程，什么 GIL ，什么同步异步就别去了解了，更不用去比较它们的优缺点，多一事不如少一事。要堕落点，这是一直成为菜鸟的必要因素之一。 \n 不要对 \nPython 解释器\n有什么好奇，解释器是怎么工作的完全不关菜鸟的事情，不用理会为什么用那么多不同的 Python 实现，当然了，也别去研究为啥 Python 能扩展 C 也能被其它语言扩展。 \n Python 安装完后就是一顿操作猛如虎，管它什么\n虚拟环境\n操作，管它什么P\nEP8 代码规范，\n会用 pip install ，会打开编辑器撸代码就行。\n至于什么计\n算机网络，\n各种协议和分层以及报文传输，什么 socket 这些就更不用去费心了，菜鸟要的是佛系，算\n法和数据结构能\n避开尽量避开。\n至于那些什么WS\nGI 、Docker容器、Nginx 啥\n的就更不用说了，嘿嘿。\n能用百度就不要用Goo\ngle，少用\nGitH\nub。\n\n\n\n\n\n\nBug 能少写尽量少写，不要\n老是去敲代码\n，敲多了，\n调试\n多了，一不小心熟能生巧了可咋整，还当不当菜鸟儿了？\n就说这么些吧，在一直成为菜鸟这条路上要加油，会遇到许多困难，不过不要怕，就像有人说的：微笑的面对它，消除恐惧的最好方法就是面对恐惧，坚持才是胜利，加油，奥利给 ！！！\n \n此文根据小程序【学习Python的正确姿势】中文章改编，如有转载请注明来源"},
{"url": "https://www.douban.com/note/710120042/", "title": "Python之禅", "article": "The Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n优美胜于丑陋（以编写优美的代码为目标） \n明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） \n简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） \n复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） \n扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） \n间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） \n可读性很重要（优美的代码是可读的） \n即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） \n不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） \n当存在多种可能，不要尝试去猜测,而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） \n虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） \n做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） \n如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） \n命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）"},
{"url": "https://www.douban.com/note/722950151/", "title": "Python Excel处理库openpyxl详解", "article": "openpyxl是一个第三方库，可以处理xlsx格式的Excel文件。pip install openpyxl安装。\n读取Excel文件\n需要导入相关函数\nfrom openpyxl import load_workbook\n# 默认可读写，若有需要可以指定write_only和read_only为True\nwb = load_workbook('pythontab.xlsx')\n默认打开的文件为可读写，若有需要可以指定参数read_only为True。\n获取工作表--Sheet\n# 获得所有sheet的名称\nprint(wb.get_sheet_names())\n# 根据sheet名字获得sheet\na_sheet = wb.get_sheet_by_name('Sheet1')\n# 获得sheet名\nprint(a_sheet.title)\n# 获得当前正在显示的sheet, 也可以用wb.get_active_sheet()\nsheet = wb.active\n获取单元格\n# 获取某个单元格的值，观察excel发现也是先字母再数字的顺序，即先列再行\nb4 = sheet['B4']\n# 分别返回\nprint(f'({b4.column}, {b4.row}) is {b4.value}') # 返回的数字就是int型\n# 除了用下标的方式获得，还可以用cell函数, 换成数字，这个表示B2\nb4_too = sheet.cell(row=4, column=2)\nprint(b4_too.value)\nb4.column返回B, b4.row返回4, value则是那个单元格的值。另外cell还有一个属性coordinate, 像b4这个单元格返回的是坐标B4。\n获得最大行和最大列\n# 获得最大列和最大行\nprint(sheet.max_row)\nprint(sheet.max_column)\n获取行和列\nsheet.rows为生成器, 里面是每一行的数据，每一行又由一个tuple包裹。\nsheet.columns类似，不过里面是每个tuple是每一列的单元格。\n# 因为按行，所以返回A1, B1, C1这样的顺序\nfor row in sheet.rows:\n  for cell in row:\n    print(cell.value)\n# A1, A2, A3这样的顺序\nfor column in sheet.columns:\n  for cell in column:\n    print(cell.value)\n上面的代码就可以获得所有单元格的数据。如果要获得某行的数据呢？给其一个索引就行了，因为sheet.rows是生成器类型，不能使用索引，转换成list之后再使用索引，list(sheet.rows)[2]这样就获取到第二行的tuple对象。\nfor cell in list(sheet.rows)[2]:\n  print(cell.value)\n如何获得任意区间的单元格？\n可以使用range函数，下面的写法，获得了以A1为左上角，B3为右下角矩形区域的所有单元格。注意range从1开始的，因为在openpyxl中为了和Excel中的表达方式一致，并不和编程语言的习惯以0表示第一个值。\nfor i in range(1, 4):\n  for j in range(1, 3):\n    print(sheet.cell(row=i, column=j))\n    \n# out\n<Cell pythontab.A1>\n<Cell pythontab.B1>\n<Cell pythontab.A2>\n<Cell pythontab.B2>\n<Cell pythontab.A3>\n<Cell pythontab.B3>\n还可以像使用切片那样使用。sheet['A1':'B3']返回一个tuple，该元组内部还是元组，由每行的单元格构成一个元组。\nfor row_cell in sheet['A1':'B3']:\n  for cell in row_cell:\n    print(cell)\n    \nfor cell in sheet['A1':'B3']:\n  print(cell)\n# out\n(<Cell pythontab.A1>, <Cell pythontab.B1>)\n(<Cell pythontab.A2>, <Cell pythontab.B2>)\n(<Cell pythontab.A3>, <Cell pythontab.B3>)\n根据字母获得列号，根据列号返回字母\n需要导入， 这两个函数存在于openpyxl.utils\nfrom openpyxl.utils import get_column_letter, column_index_from_string\n# 根据列的数字返回字母\nprint(get_column_letter(2)) # B\n# 根据字母返回列的数字\nprint(column_index_from_string('D')) # 4\n将数据写入Excel\n工作表相关\n需要导入WorkBook\nfrom openpyxl import Workbook\nwb = Workbook()\n这样就新建了一个新的工作表（只是还没被保存）。\n若要指定只写模式，可以指定参数write_only=True。一般默认的可写可读模式就可以了。\nprint(wb.get_sheet_names()) # 提供一个默认名叫Sheet的表，office2016下新建提供默认Sheet1\n# 直接赋值就可以改工作表的名称\nsheet.title = 'Sheet1'\n# 新建一个工作表，可以指定索引，适当安排其在工作簿中的位置\nwb.create_sheet('Data', index=1) # 被安排到第二个工作表，index=0就是第一个位置\n# 删除某个工作表\nwb.remove(sheet)\ndel wb[sheet]\n写入单元格\n还可以使用公式\n# 直接给单元格赋值就行\nsheet['A1'] = 'good'\n# B9处写入平均值\nsheet['B9'] = '=AVERAGE(B2:B8)'\n但是如果是读取的时候需要加上data_only=True这样读到B9返回的就是数字，如果不加这个参数，返回的将是公式本身'=AVERAGE(B2:B8)'\nappend函数\n可以一次添加多行数据，从第一行空白行开始（下面都是空白行）写入。\n# 添加一行\nrow = [1 ,2, 3, 4, 5]\nsheet.append(row)\n# 添加多行\nrows = [\n  ['Number', 'data1', 'data2'],\n  [2, 40, 30],\n  [3, 40, 25],\n  [4, 50, 30],\n  [5, 30, 10],\n  [6, 25, 5],\n  [7, 50, 10],\n]\n由于append函数只能按行写入。如果我们想按列写入呢。append能实现需求么？如果把上面的列表嵌套看作矩阵。只要将矩阵转置就可以了。使用zip()函数可以实现，不过内部的列表变成了元组就是了。都是可迭代对象，不影响。\nlist(zip(*rows))\n# out\n[('Number', 2, 3, 4, 5, 6, 7),\n ('data1', 40, 40, 50, 30, 25, 50),\n ('data2', 30, 25, 30, 10, 5, 10)]\n解释下上面的list(zip(*rows))首先*rows将列表打散，相当于填入了若干个参数，zip从某个列表中提取第1个值组合成一个tuple，再从每个列表中提取第2个值组合成一个tuple，一直到最短列表的最后一个值提取完毕后结束，更长列表的之后的值被舍弃，换句话，最后的元组个数是由原来每个参数（可迭代对象）的最短长度决定的。比如现在随便删掉一个值，最短列表长度为2，data2那一列（竖着看）的值全部被舍弃。\nrows = [\n  ['Number', 'data1', 'data2'],\n  [2, 40],\n  [3, 40, 25],\n  [4, 50, 30],\n  [5, 30, 10],\n  [6, 25, 5],\n  [7, 50, 10],\n]\n# out\n[('Number', 2, 3, 4, 5, 6, 7), ('data1', 40, 40, 50, 30, 25, 50)]\n最后zip返回的是zip对象，看不到数据的。使用list转换下就好了。使用zip可以方便实现将数据按列写入。\n保存文件\n所有的操作结束后，一定记得保存文件。指定路径和文件名，后缀名为xlsx。\nwb.save(r'D:\\example.xlsx')\n设置单元格风格--Style\n先导入需要的类\nfrom openpyxl.styles import Font, colors, Alignment\n分别可指定字体相关，颜色，和对齐方式。\n字体\nbold_itatic_24_font = Font(name='等线', size=24, italic=True, color=colors.RED, bold=True)\nsheet['A1'].font = bold_itatic_24_font\n上面的代码指定了等线24号加粗斜体，字体颜色红色。直接使用cell的font属性，将Font对象赋值给它。\n对齐方式\n也是直接使用cell的属性aligment，这里指定垂直居中和水平居中。除了center，还可以使用right、left等等参数。\n# 设置B1中的数据垂直居中和水平居中\nsheet['B1'].alignment = Alignment(horizontal='center', vertical='center')\n设置行高和列宽\n有时候数据太长显示不完，就需要拉长拉高单元格。\n# 第2行行高\nsheet.row_dimensions[2].height = 40\n# C列列宽\nsheet.column_dimensions['C'].width = 30\n合并和拆分单元格\n所谓合并单元格，即以合并区域的左上角的那个单元格为基准，覆盖其他单元格使之称为一个大的单元格。\n\n相反，拆分单元格后将这个大单元格的值返回到原来的左上角位置。\n\n# 合并单元格， 往左上角写入数据即可\nsheet.merge_cells('B1:G1') # 合并一行中的几个单元格\nsheet.merge_cells('A1:C3') # 合并一个矩形区域中的单元格\n合并后只可以往左上角写入数据，也就是区间中:左边的坐标。\n如果这些要合并的单元格都有数据，只会保留左上角的数据，其他则丢弃。换句话说若合并前不是在左上角写入数据，合并后单元格中不会有数据。\n以下是拆分单元格的代码。拆分后，值回到A1位置。\nsheet.unmerge_cells('A1:C3')"},
{"url": "https://www.douban.com/note/598171694/", "title": "穷到吃土还不看书？Python入门书单双手奉上", "article": "“不经一番寒彻骨,怎得梅花扑鼻香。”穷到吃土，却还想着升职加薪当上CEO迎娶白富美攀上人生巅峰，但是又懒散不学习，这很不科学。迎接大数据浪潮，大家可以从大数据技术的教学书籍上下手，争取成为一名思想与财富都富有的人。\n1.《Python学习手册（第4版）》\n【内容介绍】通过《Python学习手册（第4版）》，可以学习到Python的主要内建对象类型如数字、列表和字典，以及学习到使用Python语句创建和处理对象的方法、通用语法模型。我们都知道，使用函数构造和重用代码，函数是Python的基本过程工具；学习Python的面向对象编程工具，可以用于组织程序代码；学习异常处理模型，可以用于编写较大程序的开发工具。所以，想要学习Python模块的封装语句、函数以及其他工具，以便构建较大的组件，此书是不错的选择。另外，《Python学习手册（第4版）》还提供了了解高级Python工具，如装饰器、描述器、元类和Unicode处理等章目。\n【大牛评价】这书绝对是打好Python基本功的一等秘籍，从入门到进阶它都有提及，而且书中有超多浅显易懂的例子，如果之前没有接触过Python，那此书非常适合阅读。\n2.《笨办法学Python（第3版）》\n【内容介绍】《“笨办法”学Python（第3版）》是一本Python入门书籍，适合对计算机了解不多，没有学过编程，但对编程感兴趣的读者学习使用。此书结构非常简单，其中覆盖了输入/输出、变量和函数三个主题，以及一些比较高级的话题，如条件判断、循环、类和对象、代码测试及项目的实现等。每一章的格式基本相同，以代码习题开始，按照说明编写代码，运行并检查结果，然后再做附加练习。这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲授到完整项目的实现，让初学者从基础的编程技术入手，最终体验到软件开发的基本过程。\n【大牛评价】hard way（笨办法）比较适合起步编程，作为Python的入门挺不错。\n3.《利用Python进行数据分析》\n【内容介绍】此书介绍了NumPy（Numerical Python）的基础和高级知识，从pandas库的数据分析工具开始利用高性能工具对数据进行加载、清理、转换、合并以及重塑的方法，利用matplotlib创建散点图以及静态或交互式的可视化结果的方法，利用pandas的groupby功能对数据集进行切片、切块和汇总操作的方法，以及处理各种各样的时间序列数据的技巧。《利用Python进行数据分析》实操性较强。\n【大牛评价】第一次看的时候还不知道AQR是干啥的，实习的时候发现作者竟然是AQR的？！又看了几遍。\n4.《集体智慧编程》\n【内容介绍】《集体智慧编程》全书内容翔实，包括协作过滤技术（实现关联产品推荐功能）、集群数据分析（在大规模数据集中发掘相似的数据子集）、搜索引擎核心技术（爬虫、索引、查询引擎、PageRank算法等）、搜索海量信息并进行分析统计得出结论的优化算法、贝叶斯过滤技术（垃圾邮件过滤、文本过滤）、用决策树技术实现预测和决策建模功能、社交网络的信息匹配技术、机器学习和人工智能应用等。以机器学习和计算统计为主题背景的《集体智慧编程》，专门讲述如何挖掘和分析Web上的数据和资源，以及如何分析用户体验、市场营销、个人品味等诸多信息，并得出有用的结论，再通过复杂的算法来从Web网站获取、收集并分析用户的数据和反馈信息，以便创造新的用户价值和商业价值。本书是Web开发者、架构师、应用工程师等专业人士的绝佳选择。\n【大牛评价】以具体实例的方式来展示Python的编程技巧，受益良多。\n5.《Python算法教程》\n【大牛评价】如果你看过算法导论，这本书便是对简单算法的Python实现；如果你只读过学习手册，那么这本浅显易懂的书可以作为算法的启蒙书。\n【内容介绍】《Python算法教程》分别介绍了树、图、计数问题、归纳递归、遍历、分解合并、贪心算法、复杂依赖、Dijkstra算法、匹配切割问题以及困难问题及其稀释等内容。每一章结束之处均有练习题和参考资料，为读者的自我检查以及进一步学习提供了较多的便利。众所周知，Python是一种面向对象、解释型计算机程序设计语言，它的应用领域非常广泛，包括数据分析、自然语言处理、机器学习、科学计算以及推荐系统构建等。更多大数据与商业智能领域干货、兼职机会及行业资源分享等，欢迎注册大圣众包威客平台（\nhttp://www.dashengzb.cn/\n），或添加大圣妹个人微信号（dashengmeme）。本书主要关注经典的算法，但同时会为读者理解基本算法问题和解决问题打下很好的基础。《Python算法教程》适合对Python算法感兴趣的初中级用户阅读和自学，也适合高等院校的计算机系学生作为参考教材来阅读。\n6.《Python核心编程（第3版）》\n【内容介绍】《Python核心编程（第3版）》共分为三部分。第一部分讲解了Python的一些通用应用，包括正则表达式、网络编程、Internet客户端编程、多线程编程、GUI编程、数据库编程、Microsoft Office编程、扩展Python等内容。第二部分讲解了与Web开发相关的主题，包括Web客户端和服务器、CGI和WSGI相关的Web编程、Django、Web框架、云计算、高级Web服务。第三部分则为一个补充/实验章节，包括文本处理以及一些其他内容。本书适合具有一定经验的Python开发人员阅读。\n【大牛评价】其他的Python基础教程居然都没讲多线程，我是为了学习多线程才看的这本书，可以一直放在手边，随时翻看。\n时势造英雄，投身现在火热的大数据浪潮，学习相关的大数据技术，定能乘风破浪！\nQQ群二维码请扫："},
{"url": "https://www.douban.com/note/741431238/", "title": "Python学习小皮鞭", "article": "11月10日\n今天学习了基础知识，一个是简单的输入输出，加减乘除，另外是eval、区间索引[a,b]两个函数。\n考虑到我是个没长劲儿的人，所以写个日志督促自己。\n11月11日\n听说整个豆瓣是完全用python编写的，我突然对这个语言产生了一点不信任感。\n学了if/elif/else、while循环和def定义函数的用法。但是晚上有电影，怕是没时间实践了。\n11月12日\n真的听起来很简单但是做起来很难，丢三落四的。费了半天劲写了个汇率计算的函数，自以为天衣无缝，结果碰到个傻队友一招破功。只好自行修了bug——\n今天学了turtle库的用法，想起了小学时候学的logo语言，无比亲切。今天只顾得上实践汇率计算，明天再画图吧。\n11月13日\n今天的内容竟然就是拿来对付昨天的傻队友的try/except，非常好！我决定重新写个程序羞辱他。今天另外还学了str.format（）这个可以夹楔的函数，非常有用，尤其是反复调用的时候。\n11月14日\n今天学了math库，怎么说呢，我连小乌龟库还没掌握好呢……学了list的各种运算方法，不由得想起了矩阵。明天会学习怎么把序列拼成矩阵吗？有点激动。\n11月15日\n并没有矩阵。\n今天学了datetime库，这个库有点棒，但是被datetime.datetime搞晕了，为啥会出现两次？算了明天再说吧。这两天忙得没时间写代码。\n11月16日\n一个加班的周六，继续和datetime死磕。\n11月19日\n好几天没更新日志，但是学习还在继续的。\n学到了列表list和元祖tuple的区别，并且学习了集合set的计算方法。老实说，这个跟数学里的集合运算不完全一样，好在暂时还用不到数学里的排列组合知识，我已经快把公式忘光了。\n还学了字典dict，其实就是映射吧。感觉随着学习的深入，迫切地需要复习。本周也是六天工作日，只能周日复习了。\n11月20日\n今天学习了isnumeric（）判断是否只有数字和isalpha（）判断是否只有字母，感觉这个应用范围不是很广啊，为什么不直接设计一个判断是否有数字/字母的函数呢？\nbreak和continue因为有C语言的印象，接受起来还是比较容易的，其实说到底是逻辑问题。逻辑理顺了，代码读起来还是有点爽的。\n11月24日\n终于等到一个周日，做好翻译开始上机操作绘图（turtle库用手机没法调用）。\n成果如下：\n一棵会发光的树\n12月1日\n日记都快成周记了。不过也是没办法，工作日下班到家太晚，基本做个翻译就得睡了。\n言归正传。这周学习了json（不是Jason）文件的读取和写入方法，顺带了解了csv文件的规则（原来c = comma啊哈哈哈哈）。csv文件因为和excel可以互通，瞬间感觉好像马上就可以在工作中一展拳脚了呢！\n实际操作上温习了try/except、for循环和math库。没错，实际技能和理论学习的进度就是差这么多。不过俗话说得好：P≠NP。多多练习才是学习的根本！\n（顺便发现公司的程序员也在学python，这是不是意味着哪天编辑干不下去了可以考虑转岗程序员？哈哈哈哈）\n临睡前把datetime库玩了一下。一定要分清楚datetime格式不是list格式。以及isocalendar()用来算周数简直太棒了。以后再也不用拿着万年历算这是第几周啦！开心！\n12月2日\n继续练习datetime和math两个库，加入了元祖()和集合set{}的练习。虽然说list和set是不一样的，但是在元素无重复的情况下，似乎可以通用？\n另外要再次强调，range（）和区间索引[]都是左闭右开，不要忘记这件事！\n12月3日\n出差回来的路上听了一节爬虫课。不得不说，爬虫真的太牛逼了，这也解答了我多年的疑惑：为什么有些直播的数据大得可怕，就是你觉得不可能有那么多人二半夜不睡觉看一个小姑娘在那儿碎碎念然后不断发弹幕——但其实，他们只需要用爬虫自动打开网页、登录网站、点赞发弹幕、关闭网页，然后无数次循环这个过程，就可以了。所以你看到的数字就是你看到的吗？又不是所有网站都是豆瓣。\n回归正题。我有一个自学的经验法则，就是同样的内容听两个人各讲一遍，比听同一个人讲两遍，形成的印象更深刻，更立体，更全面——这就像人用两只眼睛看一只鹅，这只鹅就瞬间立体起来。\n所以昨天我就找了另一个平台，重新听了已经学过的知识，结果就是我对列表list、元组tuple、集合set获得了重新认识。也就是说，在确定它们之间的相似性后，更加明确了具体的不同和应用场景。点名感谢b站up主小甲鱼，虽然你很饶舌但是知识很系统，很扎实，比很多微信公号的“0基础python入门”给力多了。\n12月5日\n买了fishc的终身VIP，因为我需要做作业。\n纠正了之前的一个误会，其实list、tuple和字符串是一类（都是序列），set应该是另一回事，不应该混为一谈。系统学习了字符串的各种方法，但是根本不可能记住，只能遇到的时候再查手册了。也系统学习了格式化的符号系统，除了十六进制和八进制实在是玩不太来，剩下的都比较好理解。每太搞懂闭包的特点，决定等做作业的时候再搞懂了。\n12月6日\n递归函数就是不断调用自身的函数，但是必须有触底反弹，不然就会报错。斐波那契数列原来是从兔子繁殖来的，可见兔子是人类数学进步的阶梯，当然还要加上鸡。\n12月7日\n周六！终于来了！不上班的周六！啊！！！\n暂时没有进度，一整天都在写作业，大概写了十几条代码吧。开始慢慢养成一些习惯了，但是代码优化上还有很长的路要走。\n最开心的是写成了一个猜随机数大小的小游戏，而且乐此不疲地玩了起来。。。。开心得像个5岁的孩子！\n12月8日\n截止当晚，两天累计写了33条代码。脑子快宕机了。事后反思，大概还是没有养成画逻辑图的习惯，画图能极大解放脑容量，手不能懒。\n数学思维和代码思维真的不一样。因为数学是单次实现，所以需要的是用尽可能少的表达式表达尽可能多的内容。代码可以多次实现，所以需要的是用尽可能简单清晰的表达式，配合循环和递归实现复杂的功能。这是我在编写水仙花数的代码后获得的心得。\n对全局变量和内嵌函数有了更深的认识，但是尽可能还是不要用global 和 nonlocal来修改全局/外层函数变量，容易产生多米诺效应。\n12月9日\n学会了两个超级有用的BIF：filter(function, iterable) 和map(function, iterable)，搭配lambda函数简直吊炸天！\nfilter()的作用是通过function过滤iterable里的每个值，将结果为true（不为0）的结果导出。eg. list(filter(lambda x: x%2, range(0,10)))，结果是[1,3,5,7,9]\nmap()的作用是通过function加工iterable里的每个值，并返回加工后的结果。eg.list(map(lambda x: x%2, range(0,10)))，结果是[0,1,0,1,0,1,0,1,0,1]\n注意：\n1. 以上两个BIF的结果其实是个对象，所以要得到结果应该前面加list。\n2. map()这个BIF的牛逼在于iterable可以添加多个，比如 g = list(map(lambda x,y: [x,y],range(0,4),range(6,10)))，结果是[[0,6],[1,7],[2,8],[3,9]]\n12月10日\n递归真的是个好玩意！虽然说能用迭代就不要用递归，毕竟太太太占用内存了，但是谁管得住自己偷懒的本能！\n以下作业充分暴露了我懒惰的本性（如果说懒惰是优秀程序员的必备属性，那我可能是天才）："},
{"url": "https://www.douban.com/note/746030300/", "title": "我是如何十天时间学习Python的。", "article": "细水长流这个词太容易蒙蔽人，因为觉得细水长流能积累下来的人，都只考虑了流入，而没有考虑流出。无论是学习还是做事，兵贵速不贵久。\n以前总听家长教育说，哪怕你每天背10个单词，一年你也能背下来365个词。曾经我践行着这个理念，发现几个月下来一个新单词都没记住。后来，在大学的时候复习GMAT和托福的时候，每天背单词的数量都不会低于500。虽然最后种种原因没有出国，但是我的英语的底子就是从这个时候打下来的。人的大脑是有一定遗忘率的，背单词是如此，如果你每天没有背够一定的数量，那么还不够你大脑遗忘的，同样，学习也是如此，如果你每天没有接受足够量的知识，那么大脑很快会把你新学的所有知识遗忘。应该说，学习的核心是短时间的爆发性量变导致的质变。这应该是我零基础用了十天学Python的唯一方法。\n一、分主次，定目标。\n我觉得学习东西并不一定是好事，因为学习东西本身就有一定的机会成本存在，如果学习的东西用处不大，或者说学习了东西并不能物尽其用，那么自身花费的时间就成了沉没成本。作为一个而立之年的人，时间的宝贵程度已经不像20出头的时候低了。\n对于我来说，主业很明显，是命理，所以我学的一切东西都应该是围绕着主业的。所以这时候，第一，我不能放弃平时的工作时间去学习，第二，我不能把Python所有的模块都学完，我只需要学我需要的那部分知识，面向对象的思路、爬虫和公众号开发。定了这个目标之后，就有很多的知识我不需要学，可以集中精力学我想要的那部分内容。\n如果你的目标就是把想学的这门知识做成主业，那么心无旁骛的系统学习就是必须的了。如果当你主业还没有学的可以的时候，主业的辅助知识就不要去想了。\n二、所谓心无旁骛，所谓专注，就是时间\n我和一个客户说，我就是每天都在花钱学习，因为我学习了，就不能很及时的回微信，收入也就必然减少，甚至婉拒一部分收入。每天我投入在学习Python中的时间是12到16小时，如果白天比较忙的时候，一般会通宵把课程听完。\n其实人脑和肌肉是一样的原理，如果你能跑200米，然后有几次你跑了300米，那么肌肉就会有记忆，以后都能跑300米。人的大脑也是如此，这个我们在前文中说到了，大脑会有一定的遗忘率，如果你能超越这个遗忘率，那么你就能记住新学的知识。其实在我学习的时候，我慢慢发现，在很疲惫的时候，意识不是很清楚的时候，这时候凭借意志力继续学习获得的新知识，掌握的牢固程度往往要更高。\n每天12到16个小时，我觉得这是学会一项技能的必要条件。不要相信吸水长流，童话里永远都是美好的。\n不过如果你觉得我的大脑有什么特异功能的话，最多最多，现在遇到两位数乘以两位数我都会5秒内心算出结果。巅峰时期可以12秒心算三位数乘以三位数。\n三、学习的是本质，不是细枝末节\n在我自己的八字课里，大力度讲本质，小力度讲基础知识。其实从2018年至今，我开了四次八字课，每次课都有能完全学懂，可以步入实践状态的学员。其实我对于八字的授课方式，就是我自己学习方法的浓缩。和我的师父教我不同，我主张学员把基础知识打印出来，可以随时翻看，不需要强行记忆，但是需要深深地刻在脑海里的东西，就是八字作用的本质。这个本质，就是思路，思路对了，基础知识经过大量的练习就可以牢固。但是如果思路都错了，基础知识再牢固又有什么用呢？\n翻回来我们来说学习语言。Python虽然是一门编程语言，但是其实也是一门语言。语言的本质就是词性，词性是语法的基础，对应了程序语言里，叫类型。所以如果你也是python的初学者，一定会在各种类型的变换里找不到北，这是其一。\n其二，语法里不可获缺的一个词就是动词，编程语言也不例外，一个一个函数就相当于一个一个动作，你起名，创造名词，然后利用动词去连接。这就是程序最本质的东西——它是一门语言，要用学习语言的思维来学。\n再说面向对象。面向对象就像从头到尾写一道小学应用题。类里给出题目的条件，然后函数依据给的条件来解题，最后调用则好像写了一个“答：这道题的答案是××”。\n在我看来，学东西学的是思路，思路通了，细枝末节可以查，可以百度。至少我团队的几个程序员，没有一个不百度的。\n所以，总结起来，就是用最集中的精力去理解一项知识的整体思路，遍历所有细枝末节的知识点，知道每一个知识点能做什么事情，就可以了。剩下的时间，就是大量的去实践练习，用学到的思路加上知识点去实现自己想要的功能。知识点掌握的不牢固就翻回去再去看知识点，或者去百度。知识点从来都不是死记硬背下来的，而是练出来的。就像记得再熟的单词，没有无数的阅读也会忘记。八字学的再好，不去实践，也只能成为屠龙之术。"},
{"url": "https://www.douban.com/note/697593642/", "title": "孤荷凌寒自学python第十五天python循环控制语句", "article": "孤荷凌寒自学python第十五天python循环控制语句\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\npython中只有两种循环控制语句\n一、while循环\nwhile 条件判断式 1：\n如果 条件判断式1 返回True\n将执行此代码块的内容\n而且此代码块的内容执行完成后\n将重新判断条件判断式1\ncontinue #如果出现此命令，则本代码块此行后面的语句不再执行，然后直接重新判断条件判断式1，以期再次执行本代码块。\nbreak #如果出现此命令，则完全跳出while循环，直接执行while循环代码块后面的代码。而且本代码块在此行后面的各行代码也不再执行。\nelse :\n如果 条件判断式1 返回False\n将执行此代码块的内容\n而且执行完本代码块的内容后\nwhile循环就结束了。\n二、for循环\npython的for循环被简化，没有：\nfor (i=1;i++;i<10)\n这样的计数循环方式。\n只有对象循环方式：\nfor 对象 in 序列或集合\n格式如下：\n1 序列或集合的对象循环：\nfor 对象变量 in 序列或集合 ：\n每执行到此代码块一次\n就从【序列或集合】中获取下一个【对象变量】\n如果【对象变量】还有，那么\n就继续执行此代码块。\n执行完此代码块后，又重复此代码块的开头第一条语句，\n从【序列或集合】中获取下一个【对象变量】\n如果【序列或集合】中的【对象变量】被全部遍历完了\n就结束整个for循环。不再进入此代码块，\n转而直接去执行for代码块后面的语句。\n2 字典中对象的循环\nfor key的对象变量 ，value的对象变量 in 字典对象.items() :\n每执行到此代码块一次\n就从【字典对象.items()】中获取字典中的下一个字典元素\n如果【字典元素】还有，那么\n就将当前字典元素的key赋值给【key的对象变量】\n将当前字典元素的value赋值给【value的对象变量】\n并且继续执行此代码块。\n执行完此代码块后，又重复此代码块的开头第一条语句，\n从【字典对象.items()】中获取字典中的下一个字典元素\n如果【字典对象.items()】中的【字典元素】被全部遍历完了\n就结束整个for循环。不再进入此代码块，\n转而直接去执行for代码块后面的语句。\n测试：\nlstA=list('由于孤荷凌寒在中等师范学校三年根本没有学习英语，致使英语完全落后了。而读完三年中等师范学校，就在一个乡村小学教书去了，在大山的怀抱中，似乎与文明都隔绝了。')\ni=0\nwhile i<len(lstA):\nprint(lstA[i])\ni+=1\nelse:\nprint('全部输出完成')\n运行结果 ：(此输出结果将占据多行，因此可能删除了)\nlstA=list('由于孤荷凌寒在中等师范学校三年根本没有学习英语，致使英语完全落后了。而读完三年中等师范学校，就在一个乡村小学教书去了，在大山的怀抱中，似乎与文明都隔绝了。')\nfor char in lstA:\nprint(char)\n输出结果：(此输出结果将占据多行，因此可能删除了)\ndicA={'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\nfor key,value in dicA.items():\nprint(key,\"=\",value)\n运算结果：\n姓名 = 李四\n性别 = 男\n身高 = 180\n体重 = 74\n职业 = 经理\n爱好 = 书法\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1cc3VucjmNyHewtZN9kobMQ\n  密码：x0x7\nBilibili:\nhttps://www.bilibili.com/video/av35838870/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/138652501"},
{"url": "https://www.douban.com/note/503948267/", "title": "Python书单，不将就", "article": "有小伙伴询问Python的书，哎呀，动力所致，书单来了。9本，涵盖范围蛮大的。Python热持续中，入门计算机首选语言。。。\n1、父与子的编程之旅\n作者：Warren Sande Carter Sande\n译者：苏金国　易郑超\n书号：978-7-115-36717-4\n定价：69.00 元\n开本：16\n页数：452\n推荐指数：★★★★★\n推荐理由：\n原版Amazon 最受欢迎的青少年编程图书\n最简单易学的内容组织方式，老少皆宜\n第一版获Jolt大奖\n吐槽指数：★★★★★\n吐槽理由：中文书名很出戏。原版书名：Hello World!: Computer Programming for Kids and Other Beginners，在读的很多是Other Beginners，所以这本书是适合你的，放心入。\n上到8岁，下到88岁，都可以阅读这本书！Python初学者很多，大家不断刷新对内容简易程度的要求，因此小编将这本最简单易学的入门书推荐给大家，估摸着很多人会喜欢。其实人邮的另一本《趣学Python》（原书名Python for Kids）有不少初学者关注，相信很多人也不愿意错过这本，兴许你更喜欢这本书的风格，毕竟第1版厮杀过Jolt奖！\n2、Python基础教程(第2版·修订版)\n作者：Magnus Lie Hetland\n译者：司维 曾军崴 谭颖华\n审校：钟读杭\n书号：978-7-115-35352-8\n定价：79.00 元\n开本：16\n页数：488\n推荐指数：★★★★★\n推荐理由：\n各大网店最畅销Python入门图书\n经典教程全新改版，10个项目引人入胜\n主打Python 2.5，Python 3上也能运行\n吐槽指数：★\n吐槽理由：之前非修订版的翻译是被吐槽的，不过修订版重新审读了，已经不是问题，敬请购买。\n全书分为三部分。第一部分讲述Python语法，没有废话，还掺入了一些Python 3.0要注意的细节。第二部分介绍了常用的GUI、框架等应用，点到即止，算是为第三部分做铺垫了，从数目众多的应用中可以了解到Python的强大。第三部分是Project，全书最大的亮点，大家肯定喜欢。\n3、编程导论\n作者：John V. Guttag\n译者：梁杰\n书号：978-7-115-38801-8\n定价：59.00 元\n开本：16\n页数：284\n推荐指数：★★★★★\n推荐理由：\nMIT最受欢迎的开放计算机课程的教材，由MIT前计算机系主任编写，通俗易懂。主要目标是帮助读者掌握并熟练使用各种计算技术，书中涵盖了Python的大部分特性。\n吐槽指数：★★★★\n吐槽理由：中文书名古板兼表达不清。原版书名：Introduction to Computation and Programming Using Python，《Python计算机编程入门》之类的就可以嘛，你说对吧？这么优秀的一本Python书，书名都不讲清楚......伤~\n4、Python编程入门（第3版）\n作者：Toby Donaldson\n译者：袁国忠\n书号：978-7-115-33374-2\n定价：39.00 元\n开本：16\n页数：212\n推荐指数：★★★★\n推荐理由：\n简洁的步骤和解释，助你快速上手\n学习Python基础知识的首选图书之一\n吐槽指数：★★\n吐槽理由：内容简洁，不够细致，只有200页。\n培生的小兔子系列向来是值得推荐的入门书，已经出版《HTML5与CSS3基础教程（第8版）》《JavaScript基础教程（第9版）》《PHP基础教程（第4版）》（最后一本只有电子书），读者反响都不错。\n5、Python开发实战\n作者：BePROUD股份有限公司\n译者：盛荣\n书号：978-7-115-32089-6\n定价：79.00 元\n开本：16\n页数：368\n推荐指数：★★★★\n推荐理由：\n日本Python第一畅销\n强调项目开发实战\n吐槽指数：★★\n吐槽理由：这是一本偏工程的图书，没怎么讲Python语言基础知识，直接告诉你怎么搭建开发环境，做好代码管理和文档管理以及缺陷管理等工作。但是，对工具的介绍没有做到全面深入。\n本书主要内容包括：团队开发环境的搭建与管理/ ticket驱动开发/ 源代码管理(Mercurial)/ PyPI包/ Jenkins持续集成/ 性能优化（nginx与gunicorn)/ GAE开发/ Django框架……\n6、Python网络编程攻略\n作者：Dr. M. O. Faruque Sarker\n译者：安道\n书号：978-7-115-37269-7\n定价：45.00 元\n开本：16\n页数：188\n推荐指数：★★★★★\n推荐理由：\n使用Python进行网络编程第一书\n实例多，快速上手\n吐槽指数：★\n吐槽理由：实例解释不够详细。\n本书全面介绍了Python网络编程涉及的重要问题，包括网络编程、系统和网络管理、网络监控以及Web应用开发。作者通过70多篇攻略，清晰简明地描述了各种网络任务和问题，提出了可用于多种场景的解决方案，并细致地分析了整个操作过程。无需多少Python基础知识，就可以轻松理解这些示例。如果你想开发依赖于网络协议的实用Web应用和网络应用，绝对不能错过这本书。\n7、Python计算机视觉编程\n作者：Jan Erik Solem\n译者：朱文涛 袁勇\n书号：978-7-115-35232-3\n定价：69.00 元\n开本：16\n页数：284\n推荐指数：★★★★★\n推荐理由：\n亚马逊计算机视觉类图书No.1\n详细剖析多种计算机视觉工具\n大量示例极易上手\n吐槽指数：★\n吐槽理由：内容偏少，偏实例，详细介绍API，不可能面面俱到。\n本书是计算机视觉编程的权威实践指南，通过Python语言讲解了基础理论与算法，并通过大量示例细致分析了对象识别、基于内容的图像搜索、光学字符识别、光流法、跟踪、3D重建、立体成像、增强现实、姿态估计、全景创建、图像分割、降噪、图像分组等技术。\n8、Python数据分析基础教程\n作者：Ivan Idris\n译者：张驭宇\n书号：978-7-115-33940-9\n定价：49.00 元\n开本：16\n页数：244\n推荐指数：★★★★★\n推荐理由：\nNumPy中文入门教程，Python数据分析首选\n从最基础的知识讲起，手把手带你进入大数据挖掘领域\n囊括大量具有启发性与实用价值的实战案例\n吐槽指数：★\n吐槽理由：只是个入门书，讲得不深也不广。不过，入门书不就应该这样吗？\n9、Flask Web开发\n作者：Miguel Grinbergs\n译者：安道\n书号：978-7-115-37399-1\n定价：59.00 元\n开本：16\n页数：224\n推荐指数：★★★★★\n推荐理由：\n从安装与环境设置讲起，一步一步搭建服务器端Web应用\n全流程讲解Web应用开发，给出最佳实践\n本书共分三部分，全面介绍如何基于Python微框架Flask进行Web开发。第一部分是Flask简介，介绍使用Flask框架及扩展开发Web程序的必备基础知识。第二部分则给出一个实例，真正带领大家一步步开发完整的博客和社交应用Flasky，从而将前述知识融会贯通，付诸实践。第三部分介绍了发布应用之前必须考虑的事项，如单元测试策略、性能分析技术、Flask程序的部署方式等。"},
{"url": "https://www.douban.com/note/730855916/", "title": "写给编程小白的Python学习指南：零基础该怎样入门", "article": "（1）兴趣来源\n之所以对Python情有独钟，很大程度是由于它易于上手；另一方面，Python有很多库，拿来复用或者调整一下，就能实现你脑内的想法。\n我在大学一开始对C语言不感兴趣，却很快被Python吸引了，我那会儿刚开始玩的第一个项目是\n贴吧爬虫\n，将贴吧上的“只看楼主”爬取下来，并且生成txt阅读。\n我那时将几部《哈利·波特》同人爬了下来，看见自己的爬虫运行起来后，心中的成就感绝对是爆棚的，毕竟手工复制粘贴绝对要花\n好几个小时\n，而爬虫只需要\n3秒钟\n。\n（2）Python能做什么？\n准备入坑的朋友也许会想知道。这样说吧，你不应该问Python能做什么，而是\n你想做什么\n。\n选择一个你喜欢的方向吧，比如\n爬虫开发\n，它能把你想要的信息爬下来，可以变为表格文件，可以存进数据库；\n然后你可以对这些信息进行相关的\n数据分析\n，例如创建一个模型预测未来的走势（金融方面也有类似应用），或者是根据信息统计出“豆瓣本年度最受欢迎的图书TOP100”、“豆瓣全体用户地域分析”，配合相关的库还能变成图表，更直观地呈现数据。\n不知道你有没有看过《哈利·波特与看起来像一大坨灰烬的肖像》这本AI写的小说，利用Python再搭配相关的库，你也能建立一个文本生成器，让Python根据前7部小说创建新的小说内容！\n还有\nweb开发\n方向，你可以创建软件或者app，让你的各种点子实现；\n目前\n人工智能\n也用到了Python，这个方向是教你的程序，让它变得和人“更相似”，让程序识别人脸，识别图像，写诗歌，做客服……\n游戏开发\n，试着用Python弄一个简单的小游戏。flappy bird，2048……总之，你想做的东西，Python都能替你实现。\n（3）如何开始？\n我的建议是一本相关的书籍，和网络课程。万丈高楼平地起，在你实现你想做的事情前，你先得进行\n基础学习\n，弄清楚Python这门语言：它有什么语法？它有哪些基础知识？\n在此我推荐\n廖雪峰的课程\n，都是文字，先看一遍，了解一下基础知识。\n将上面这幅图的知识看一遍，代码也敲一下，弄清楚这样的语句有什么作用。重点阅读\nPython基础\n和\n函数\n这两部分。\n其他太难的、如果读了几遍也不懂的，可以暂时忽略，毕竟后面可以通过项目弥补。\n过了一遍廖雪峰的课程后，可以阅读一本Python的相关书籍。个人推荐这本：\n笨办法学Python 3\n8.6\n[美]泽德 A. 肖 / 2018 / 人民邮电出版社\n一方面用来巩固知识，另一方面可以消除畏难心理。\n（4）找个项目练手\n当你看了一遍基础知识后，可能过了一周时间了，你可以在网上找些相关的项目了。\n这些项目，可以是你感兴趣的项目，或者是你想做的项目（但有人已经实现了）。\n在哪里找？搜索引擎输入你的项目名+Python，或者在知乎、B站这种地方找。当你以后有一定的理解能力后，可以去Github。\n怎么学？这个时候，虽然你拿到了一堆积木，但还是不知道怎么拼接起来。\n方法很简单，就是模仿别人，看他们怎么做。将代码一句句看懂，用自己的话讲一遍。\n这个阶段主要是让自己有思路，把别人的东西变成自己。虽然你和别人的代码基本一致，但是想法绝不会相同。我认为学习，就是为了\n学会这种“想法”\n。\n如何去思考别人的代码，我之前的几篇Python日志已经写过了，完完整整的思考路径。\n我会想清楚他们的每一个模块负责什么功能，对于某个功能，他是怎么实现的，我以前是怎么实现的，他的方法是不是比我的更加简便；\n对于一些语句，如果不懂的话，我会去搜索引擎上找，如果还是不懂的话，我会将这句语句去掉，看看删掉这个语句后，会对程序有什么影响，测试几次后就基本知道这句话是什么意思了。\n然后我会把这部分的想法、思路记录下来，在有道云笔记，或者豆瓣上——我将它们当作自己的记忆存储器。\n而我自己的大脑，我不会将所有的代码全部记住下来，我记下的会是程序的\n实现思路\n。当我下一次做类似的项目时，就知道怎么做了。某些代码忘记的话，会找相关的笔记提醒。\n（5）之后该学什么？\n经过前四步之后，你可能做了不少项目，但不知之后要学什么了。\n你可以回到（1）和（2），当初Python吸引你的地方是哪些东西呢？你想继续沿着当前的方向走下去，还是换个方向呢？\n无论怎样走，你都绕不开知识的\n输入\n（看书）和\n输出\n（写代码）。\n书籍推荐可以到知乎找，而写代码依旧是找项目，自己通过各种方法实现。试着自己先写一遍，再看看别人是怎么写的。\n相信经过这么几步，你对Python的兴趣会越来越深，而你也能看见更大的世界。\nLife is short, you need Python!\n更多入门资料\nPython学习手册（第4版）\n7.9\n[美] Mark Lutz / 2011 / 机械工业出版社\nPython编程\n9.1\n[美] 埃里克·马瑟斯 / 2016 / 人民邮电出版社\nHead First Python（中文版）\n8.0\n巴里（Barry.P.） / 2012 / 中国电力出版社\n👉\npython3 | 菜鸟教程"},
{"url": "https://www.douban.com/note/534604587/", "title": "核心语言学无编程基础入门Python（第一章）", "article": "基本是私人笔记。编程基础0，计算机语言学、语料库语言学和自己就读的专业联系很少。\n另外本系列已经完结了，一共是六章\n。\n假设已经\n安装好了Python\n。听说Python是有2.x和3.x的区别的，但是我的专业很落后，我选择了2.x。并且听说Python在Mac机上是预装好了的，但是我还是很落后，家里只有PC机。\n但是最起码的理智我还是有的。【脚本最好单独存成一个.py文件】，而不是进入Python之后，在内存里面一行一行代码然后回车。\n运行一个脚本的方法是在命令行里写  python 1.py 然后回车（假设存的脚本文件叫 1.py）\n--------------------------------------------------------------------------------------\n1 和Python好好谈一谈（print）\n既然没有编程基础，最基本、最想入手的事情就是【告诉Python一件事，然后让Python马上把这件事复述一遍】，要用到print这个命令。基本的用法就是\nprint 【某个东西】\n（请尝试之前先把脚本存成1.py，然后在命令行里使用python 1.py调用）\n这里说的「某个东西」其实有蛮多种类的，不过现在这个阶段也不是太重要，现在只要记住可以print的对象可以是【字串/string（某个单词？）】和【数字/number（可以加减乘除？）】就好。\nprint \"Python is easy\"\n# => Python is easy\nprint 1\n# => 1\n有两个点要千万记住，第一个是字串要用引号框起来（单引号双引号倒无所谓，但你至少要用一对），第二个是看上去是数字的东西当然也可能是字串，但是你print的时候至少要告诉Python，我要的是字串的1，而不是数字的1，比如下面这一行。\nprint \"1\"\n# => 1\n估计有人嫌烦了，心想为什么一定要区分字串和数字呢。那是因为Python在运算的时候处理字串（string）和数字（number）是不一样的：两个字串加在一起会变成一个长的字串，两个数字加在一起结果要问小学数学老师。\nprint \"1\" + \"1\"\n# => 11\nprint 1 + 1\n# => 2\n具体除了+以外还允许什么运算方式请自己搜其他的教程…\n--------------------------------------------------------------------------------------\n2 Python你帮我省省心啊（=）\nprint毕竟还是蛮蠢的，你告诉它什么，它马上就做什么。有些时候我【希望Python能先记住一些事情】，我需要的时候再让它告诉我。这个时候就要用到=。而且我得找个地方让Python把某件事情记下来，找的地方要写在=前面，用法如下\na=\"so easy\"\n这里我就把so easy这个字串（其实是\"so easy\"）存进a这个变量里了，这个过程被称为【赋值】（以后这个词估计会经常听到）。变量的名字（比如这里的a）是大家随便选的，完全看个人的格调，只要和Python系统已经分配的一些不起冲突就行了（实际上因为个人品味千差万别，起冲突的可能性真得很低）。\n不过，光是存下一个变量（赋值），系统也没什么直接的反馈，如果想确认自己存了什么，还是要用前面说过的print。\na=\"so easy\"\nprint a\n# => so easy\n（再说一次，尝试之前先把脚本存成1.py，然后在命令行里使用python 1.py调用）\n用= 进行赋值的时候，也是能进行运算的，这样就能省下 print 这一行不少的篇幅了。比如上面提到： print \"1\" + \"1\" 的结果是 11（其实是\"11\"），我们也能换个法子做这个运算\n脚本1：\na=\"1\"\nb=\"1\"\nc=a+b\nprint c\n# => 11\n脚本2：\na=\"Python \"\nb=\"so \"\nc=\"easy\"\nd=a+b+c\nprint d\n# => Python so easy\n注意脚本2里面a和b我在后面都加了一个空格哦，否则print出来的东西是三个词直接贴在一起。当然加空格这种工作也可以放在print里来完成，主要还是看气质。\n脚本3：\na=\"Python\"\nb=\"so\"\nc=\"easy\"\nprint a+\" \"+b+\" \"+c\n# => Python so easy\n对了，=也能帮着让1这种东西在数字（number）和字串（string）之间互相转换一下：转成字串用str()，转成数字用int()。另：不是表达整数的字串但还是想转数字的话用float()。自己运行一下脚本4和脚本5，大概就懂了。\n脚本4：\na=2\nb=str(a)\nc=\"016\"\nprint b+c\n脚本5：\na=\"2\"\nb=int(a)\nc=2014\nprint b+c\n----------------------------------------------\n小抄：print + = str(某数字) int(某字串)，嗯？\"\"是什么？"},
{"url": "https://www.douban.com/note/696067581/", "title": "孤荷凌寒自学python那些事第一天", "article": "孤荷凌寒自学python第一天\n初识python\n(学习过程的完整录像分享链接在文末，手写笔记图片在文末)\n一种编程语言，首先是它的语言的基本架构，python总体让人耳目一新：\n今天其实只接触到了它的数值类型，但他的精简理念已着实让我叹服了。\n数值类型：\nint\n整型数据，注意python没有long这种类型！！int就是long\nfloat\n浮点数据，注意python并不区分single 和 double\ncomplex 复数\n数值运算符：\n/ 除法 得到的结果 是：float\n// 整除\n得到结果 是：int\n% 取模\n取余数 得到的结果 是：int\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：\n（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1R0G4iDzUS5UII8R_2xM58g\n密码：nory\n（清晰度：4K：（今天的4K文件体积还比较小）\n链接：\nhttps://pan.baidu.com/s/1HHpENzo0xB3q9KN_tuNJBw\n密码：smyf\nIqiyi视频网\nhttp://www.iqiyi.com/w_19s3fa1wh1.html\n优酷视频网\nhttp://url.cn/5SmzlH0\n喜马拉雅未来书屋频道专辑：\nhttps://www.ximalaya.com/keji/19103006/135190037"},
{"url": "https://www.douban.com/note/727631156/", "title": "我与python的十年（上）", "article": "从08年刚接触python到现在已经十多年的光景了，始终贯穿着我的工作跟学习，不管出现再多的语言，出现再多的技术,我对python总是有一种割舍不掉的感情。\n刚开始接触python是因为,读书的时候想找到一门与众不懂的语言，显得自己比较厉害。就是那种想在一干同学面前 嘚瑟一下，觉得我比你们厉害。你们就会php java .net， 我会一种你们都没玩过的。也并没有想过这门语言有什么与众不同，更无法预计它在十年后的今天能登顶语言排行榜。\n当时学习的时候就是windows下面玩应该是2.7的版本，下载完之后就去搜索下如何写代码以及执行，就照着网上的教程打开了python的interactive环境，那时候根本不知道什么叫交互环境，也不知道什么叫repl。\n仅仅明白有个窗口能让我写代码，然后试着输入我们学语言的第一课，在屏幕上打印一个hello world。怯生生的在命令行入了 print(“hello world”)， 下面就显示了 ”hello world” 。好神奇啊，不用写main函数就能执行。\n随后就是开始输入 1+2 这种算数表达式之类的东西，马上都能快速的给出执行结果，觉得很有意思，试着去写个 if(true) {print(“hello world”)}这种选择结构，写完了突然发现执行不了，给我报一堆红色错误提示，去搜索了下发现python的语法不是这么写的，是靠的是缩进来控制结构的。不需要花括号，试着缩进了发现好用，紧接着想改改我写的if 里面的输出 为 hello world ly， 发现没法改，一着急就把命令行环境给关了，重新打开再写。\n来来回回这样太累，就在想其他语言我记得都是写代码在文本里面啊，难道python只能这样运行不应该。于是扒拉文档，发现原来python还有一种执行模式，运行脚本文件的，是可以把代码写到一个后缀为py的文件当中，然后随时可以修改它，就可以各种尝试自己的代码执行结果，当时的idle也就是python官方自带编辑器长这样。\n   随后就开始了各种尝试python代码的折腾，从定义变量，还是它里面内置的数据类list/dict/tuple/queue，到学习它的控制结构 if while这些， 还有异常处理 try exception else到学习定义函数，使用内置的函数。\n这些个断断续续学了个把月，基本的觉得都掌握了， 就想着我学python能干什么，去网上找，发现python大家都说可以做爬虫。试着找了网上一些爬虫例子，开始研究发，发现有些代码能看懂，有些看不懂，不管了先拿下来跑下看看，结果黏贴下来的并不能用。\n主要是python的缩进问题，然后硬着头皮把缩进改好，URL换成自己想爬的网页，跑了一下果真网页下来了。然后就去仔细看了里面的代码，发现里面有些import语句不懂是干嘛的，一查才知道这个是用来导入你想用的python模块，又学会一招。\n2010年就开始工作了工作内容主要是用的.net，python也根本用不上。随后的一两年里面就是，每天瞎看看python，然后找网上的例子去练。这个阶段其实更多的是，熟悉python的语法查漏补缺，并没有真正把python用到实际的项目中。\n期间我写了一个爬公司网站图片的爬虫，当时在做做电商业务，页面很多鞋子的照片，就想写个简单爬虫爬着玩玩，就把图片爬下来放在磁盘里，爬取得是固定网页的内容。不会整站的爬，没有那种思维，这个时期的我基本上不会碰到，那种缩进出现的简单语法问题了。不过时间太久了，我已经找不到我的这段代码，庆幸我找到了当时下载百度音乐的一段代码，彼时百度音乐还在。\n一晃眼到了2012年了，去了一家做公司做bi分析.公司有个需求，每天从固定的地方下载日志，然后进行分析入库。脑子一闪这玩意应该可以用python搞吧，征询了老大的同意。我就网上查资料如何使用python下载ftp文件，研究如何使用python去登陆ftp，切换路径下载文件解压文件这些操作对应的库函数等。\n这些都写完了，后续日志需要被一jar执行，这是一个如何fork 与 exec的问题，脑子里想到c里面有这些系统调用，那python里面应该也有，找到了python的os模块里面的system方法。于是乎整个都顺了，最后把整个调度的流程用python写了下来，这段代码我也还留着。\n当时也没有python name convention的这种概念，就是先写出来,这中间还学会了自己定义包/模块的，不是把所有代码都写到一个文件里面，比如上面自己定义了一个模块用于发邮件，一个py的package，写了个sendmail的module，也明白了 python的每个文件是一个module，多个module可以放在一个package也就是一个文件夹下，目的还是用于代码隔离，代码重用这些基本的编程概念，其他语言也都有,下面就是我写得sendmail模块下的sendhtml函数\n当时写完这个一直跑在线上，也算是我第一个正式用于生产的python项目。还是挺开心的然后觉得学有所用。除了写脚本做一些这种任务之外，我也关注了python如何去写web程序，当时学了很有名的tornado，就按照官网文档自己瞎玩，写Helloworld或者写一个表单之类的。\n13年突然有一天公司一个运营的小伙儿，去注册微信公众账号。需要去搭建一个服务用于微信的验证，老大就让他找了我，接到这个任务时候，就想到一个服务器那python很方便，聊明白他的需求之后，去查了微信的文档然后照着文档，在服务器上面来了一个麻雀版的验证服务器，很快就让他注册成功了，这段代码我也保留着。\n搞了这么三年多基本的python掌握了也算是入了门了，就去考虑把python应用到更多的地方，也顺带的提升自己的python能力促进开发。其实这个阶段我也认真的去看了一本书，中文名python核心编程，英文名《core  python  programming》也就是写这篇文章的时候，我还在回过头看这本书的英文版，就是下面的这本书，准备再次好好的梳理下自己的python知识，里面介绍python的知识点很全面，配合官方的manual，你如果坚持读下来应该比我厉害。\n未完待续......"},
{"url": "https://www.douban.com/note/534966189/", "title": "核心语言学无编程基础入门Python（第六章）", "article": "这是这个系列最后一章。再重复几个点：■ 这个系列不是写给程序员的 ■ 也不是写给「所有人」的 ■ 是写给没有编程概念、但是需要从事和语言相关工作的人的，特别是那些【希望对于所拥有的文本有完全控制权的人】\n第一章\n        \n1 和Python好好谈一谈（print）\n        \n2 Python你帮我省省心啊（=）\n第二章\n        \n3 把文字扭一扭（关于string的命令）\n        \n4 让别人也来参与一下（raw_input）\n第三章\n        \n5 我真得不想看大段的字串啊！（list的概念）\n第四章\n        \n6 原来都是烤串儿而已（slicing/indexing）\n        \n7 串儿上的肉要一块一块地吃（for ... in ...）\n第五章\n        \n8 我就问一次，如果…（if）\n        \n9 你慢慢吃吧，只要还有剩的（while）\n------------------------------------------------------------\n10 读取和写入文本（read/write）\n脚本1\nmyfile=open(\"1.txt\")\ntext=myfile.read()\nmyfile.close\n# 脚本1是说打开1.txt并且把内容全部作为一个字串存进text这个变量。（注意open和close的用法，请尽量把myfile这个变量理解为Python和文本文件【沟通的桥梁】，本身并不是一个字串）\n脚本2\nmyfile=open(\"1.txt\")\ntext=myfile.read()\nmyfile.close\nnewfile=open(\"1_new.txt\",\"w\")\nnewfile.write(text)\nnewfile.close\n# 脚本2指的是把脚本1里存好的的text变量里的字串再写入1_new.txt这个文件里。\n脚本3\nmyfile=open(\"1.txt\")\nnewfile=open(\"1_new.txt\",\"w\")\ntext=myfile.readlines()\nfor line in text:\n        newfile.write(line)\nnewfile.close()\nmyfile.close()\n#脚本3用的是readlines命令，可以【把字串的每一行都提取出来，放进一个列表里】（注：其实字串没有「行」的概念，只是扫描到\\n出现而已），用for就很容易提取出来。\n脚本4\nmyfile=open(\"1.txt\")\nnewfile=open(\"1_new.txt\",\"w\")\nline=myfile.readline()\nwhile line:\n        newfile.write(line)\n        line=myfile.readline()\nnewfile.close()\nmyfile.close()\n#脚本4用的是readline的命令，这个命令在处理大型文件的时候非常实用。因为如果用的是read，整个文件会被先一下子转成一个字串，资源耗费太大；如果用readlines效果也差不多，都是一下子读取整个文件；而readline可以做到一行一行地去读一个很大的文件。\n------------------------------------------------------------\n【隐藏章节】\n觉得依旧没有入门的人可以考虑再看看其他的，建议顺序是try, except, dictionary, tuple, class, with, def\n------------------------------------------------------------\n小抄：read readlines readline         open/close \"w\"            write"},
{"url": "https://www.douban.com/note/686624283/", "title": "Python性能优化的20条建议", "article": "1、优化算法时间复杂度\n算法的时间复杂度对程序的执行效率影响最大,在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。\n2、减少冗余数据\n如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。\n3、合理使用copy与deepcopy\n对于dict和list等数据结构的对象，直接赋值使用的是引用的方式,而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）\nimport copy\na = range(100000)\n%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)\n%timeit -n 10 copy.deepcopy(a)\n10 loops, best of 3: 1.55 ms per loop\n10 loops, best of 3: 151 ms per loop\n\ntimeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。\n4、使用dict或set查找元素\npython dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)\na = range(1000)\ns = set(a)\nd = dict((i,1) for i in a)\n%timeit -n 10000 100 in d\n%timeit -n 10000 100 in s\n10000 loops, best of 3: 43.5 ns per loop\n10000 loops, best of 3: 49.6 ns per loop\n\ndict的效率略高(占用的空间也多一些)。\n5、合理使用生成器（generator）和yield\n%timeit -n 100 a = (i for i in range(100000))\n%timeit -n 100 b = [i for i in range(100000)]\n100 loops, best of 3: 1.54 ms per loop\n100 loops, best of 3: 4.56 ms per loop\n\n使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。但是对于需要循环遍历的情况：\n%timeit -n 10 for x in (i for i in range(100000)): pass\n%timeit -n 10 for x in [i for i in range(100000)]: pass\n10 loops, best of 3: 6.51 ms per loop\n10 loops, best of 3: 5.54 ms per loop\n\n后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：\ndef yield_func(ls):\n    for i in ls:\n        yield i+1\ndef not_yield_func(ls):\n    return [i+1 for i in ls]\nls = range(1000000)\n%timeit -n 10 for i in yield_func(ls):pass\n%timeit -n 10 for i in not_yield_func(ls):pass\n10 loops, best of 3: 63.8 ms per loop\n10 loops, best of 3: 62.9 ms per loop\n\n对于内存不是非常大的list，可以直接返回一个list，但是可读性yield更佳人个喜好python2.x内置generator功能的有xrange函数、itertools包等。\n6、优化循环\n循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：\na = range(10000)\nsize_a = len(a)\n%timeit -n 1000 for i in a: k = len(a)\n%timeit -n 1000 for i in a: k = size_a\n1000 loops, best of 3: 569 ?s per loop\n1000 loops, best of 3: 256 ?s per loop\n\n7、优化包含多个判断表达式的顺序\n对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：\na = range(2000)  \n%timeit -n 100 [i for i in a if 10 < i < 20 or 1000 < i < 2000]\n%timeit -n 100 [i for i in a if 1000 < i < 2000 or 100 < i < 20]     \n%timeit -n 100 [i for i in a if i % 2 == 0 and i > 1900]\n%timeit -n 100 [i for i in a if i > 1900 and i % 2 == 0]\n100 loops, best of 3: 287 ?s per loop\n100 loops, best of 3: 214 ?s per loop\n100 loops, best of 3: 128 ?s per loop\n100 loops, best of 3: 56.1 ?s per loop\n\n8、使用join合并迭代器中的字符串\nIn [1]: %%timeit\n   ...: s = ''\n   ...: for i in a:\n   ...:         s += i\n   ...:\n10000 loops, best of 3: 59.8 ?s per loop\nIn [2]: %%timeit\ns = ''.join(a)\n   ...:\n100000 loops, best of 3: 11.8 ?s per loop\n\njoin对于累加的方式，有大约5倍的提升。\n9、选择合适的格式化字符方式\ns1, s2 = 'ax', 'bx'\n%timeit -n 100000 'abc%s%s' % (s1, s2)\n%timeit -n 100000 'abc{0}{1}'.format(s1, s2)\n%timeit -n 100000 'abc' + s1 + s2\n100000 loops, best of 3: 183 ns per loop\n100000 loops, best of 3: 169 ns per loop\n100000 loops, best of 3: 103 ns per loop\n\n三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得%的可读性最好)\n10、不借助中间变量交换两个变量的值\nIn [3]: %%timeit -n 10000\n    a,b=1,2\n   ....: c=a;a=b;b=c;\n   ....:\n10000 loops, best of 3: 172 ns per loop\nIn [4]: %%timeit -n 10000\na,b=1,2\na,b=b,a\n   ....:\n10000 loops, best of 3: 86 ns per loop\n\n使用a,b=b,a而不是c=a;a=b;b=c;来交换a,b的值，可以快1倍以上。\n11、使用if is\na = range(10000)\n%timeit -n 100 [i for i in a if i == True]\n%timeit -n 100 [i for i in a if i is True]\n100 loops, best of 3: 531 ?s per loop\n100 loops, best of 3: 362 ?s per loop\n\n使用 if is True 比 if == True 将近快一倍。\n12、使用级联比较x < y < z\nx, y, z = 1,2,3\n%timeit -n 1000000 if x < y < z:pass\n%timeit -n 1000000 if x < y and y < z:pass\n1000000 loops, best of 3: 101 ns per loop\n1000000 loops, best of 3: 121 ns per loop\n\nx < y < z效率略高，而且可读性更好。\n13、while 1 比 while True 更快\ndef while_1():\n    n = 100000\n    while 1:\n        n -= 1\n        if n <= 0: break\ndef while_true():\n    n = 100000\n    while True:\n        n -= 1\n        if n <= 0: break    \nm, n = 1000000, 1000000 \n%timeit -n 100 while_1()\n%timeit -n 100 while_true()\n100 loops, best of 3: 3.69 ms per loop\n100 loops, best of 3: 5.61 ms per loop\n\nwhile 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。\n14、使用**而不是pow\n%timeit -n 10000 c = pow(2,20)\n%timeit -n 10000 c = 2**20\n10000 loops, best of 3: 284 ns per loop\n10000 loops, best of 3: 16.9 ns per loop\n\n**就是快10倍以上！\n15、使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包\nimport cPickle\nimport pickle\na = range(10000)\n%timeit -n 100 x = cPickle.dumps(a)\n%timeit -n 100 x = pickle.dumps(a)\n100 loops, best of 3: 1.58 ms per loop\n100 loops, best of 3: 17 ms per loop\n\n由c实现的包，速度快10倍以上！\n16、使用最佳的反序列化方式\n下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：\nimport json\nimport cPickle\na = range(10000)\ns1 = str(a)\ns2 = cPickle.dumps(a)\ns3 = json.dumps(a)\n%timeit -n 100 x = eval(s1)\n%timeit -n 100 x = cPickle.loads(s2)\n%timeit -n 100 x = json.loads(s3)\n100 loops, best of 3: 16.8 ms per loop\n100 loops, best of 3: 2.02 ms per loop\n100 loops, best of 3: 798 ?s per loop\n\n可见json比cPickle快近3倍，比eval快20多倍。\n17、使用C扩展(Extension)\n目前主要有CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：\nCPython原生API\n: 通过引入Python.h头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。\nctypes\n: 通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。\nCython\n: Cython是CPython的超集，用于简化编写C扩展的过程,Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。\ncffi\n: cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。\n使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。\n18、并行编程\n因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：\n多进程\n：对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。\n多线程\n：对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。\n分布式\n：multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。\n不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。\n19、终级大杀器：PyPy\nPyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因目前pypy中还保留着GIL不过正在进行的STM项目试图将PyPy变成没有GIL的Python。如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）所以在PyPy中最好用纯Python或使用cffi扩展。随着STM,Numpy等项目的完善，相信PyPy将会替代CPython。\n20、使用性能分析工具\n除了上面在ipython使用到的timeit模块,还有cProfilecProfile的使用方式也非常简单:python -m cProfile filename.py， 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。\n作者：四川CDA数据分析师 \n来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},
{"url": "https://www.douban.com/note/743355793/", "title": "10个简单窍门带你提高Python数据分析速度（附代码）", "article": "不管在做什么事情，提示和一些小技巧总是非常有用的，在编程领域更是如此。有时候，小小的黑科技可以节省你大量的时间和精力。一个小的快捷方式或附加组件有时会是天赐之物，可以成为实用的效率助推器。\n所以，给大家介绍下自己编程时最喜欢使用的一些提示和小技巧，也是花了些时间整理的！有些可能是大家熟悉的，而有些可能是新鲜的，我相信它们会为你下一次处理数据分析的项目时提供便利。\n1.预览Pandas中的数据框数据（Dataframe）\n分析预览（profiling）是一个帮助我们理解数据的过程，在Python中Pandas Profiling 是可以完成这个任务的一个工具包，它可以简单快速地对Pandas 数据框进行搜索性数据分析。Pandas中df.describe()和df.info()函数通常可以实现EDA过程的第一步，但如果只是给出非常基础的数据预览并不能对分析那些大型的数据集提供帮助。另一方面来看，Pandas Profiling函数能通过一行代码来展示出大量的信息，而在交互式HTML报告中也是这样。\n对于一个给定的数据集，Pandas Profiling 工具包将会计算出下面的统计信息：\n\n\n由pandas profiling包算出的统计信息\n使用\n现在用一个古老的泰坦尼克数据集来演示多功能python profiler的结果：\nimporting the necessary packages\nimport pandas as pd ##使用pandas资源包\nimport pandas_profiling ##使用新安装的pandas profiling资源包\ndf = pd.read_csv('titanic/train.csv') ##读取数据形成数据框\npandas_profiling.ProfileReport(df) ##使用pandas profiling\n分析数据\n这一行就是你需要在jupyter notebook中形成数据分析报告所需的全部代码。这个数据报告十分详细，包括了所有必要的图表。\n\n\n这个报告也可以用下面的代码形成交互HTML文件（interactive HTML file）导出：\nprofile = pandas_profiling.ProfileReport(df)\nprofile.to_file(outputfile=\"Titanic data profiling.html\") ##形成Titanic data profiling.html网页\n\n\n2.Pandas图表(Plot)的交互性\nPandas中有一个内置的.plot()函数作为数据框(Dataframe)的一部分，但因为这个函数呈现的可视化并不是交互的，这使它的功能没那么吸引人。而且，使用pandas.DataFrame.plot（）函数绘制图表也并不容易。如果我们想要在没有对代码进行重大修改的情况下用pandas绘制交互式图表要怎么办？嗯，可以通过Cufflinks资源包来帮助你完成这一目的。\nCufflinks资源包将功能强大的plotly和灵活易用的pandas结合，非常便于绘图。现在我们来看看怎么安装和在pandas中使用这个资源包。\n代码示例：\n安装\nPython2.x的版本中，使用pip安装plotly和cufflink：\npip install plotly # Plotly is a pre-requisite before installing cufflinks(plotly先于cufflinks安装)\npip install cufflinks\n使用\n调用方法：\nimporting Pandas\nimport pandas as pd ##使用pandas资源包\nimporting plotly and cufflinks in offline mode\nimport cufflinks as cf ##使用cufflinks 和plotly资源包\nimport plotly.offline\ncf.go_offline() ##使用cufflink包中的函数\ncf.set_config_file(offline=False, world_readable=True)\n下面来看一下泰坦尼克数据集所展现的魔力：\ndf.iplot()\n\n\n\n右边的可视化展示的是静态的线状图，而左边的图是交互式的，并且更加详细，两个图在代码上没有重大的变化。\n3.一点点魔法\nMagic命令是Jupyter Notebook中的一组便捷功能，它们旨在解决数据分析中一些常见的问题。你可以用%Ismagic来查阅所有的Magic 命令。\n\n\n上图列举了所有可用的Magic 函数\nMagic命令有两大类：行magic命令（line magics），以单个% 字符为前缀，单行输入操作；单元magics命令（cell magics），以双%% 字符作为前缀，可以在多行输入操作。如果设置为1，我们使用magic 函数时不需要键入%。\n下面让我们来看一下，在常见的数据分析任务中一些可能会用到的命令。\n% pastebin\n% pastebin将代码上传到Pastebin并返回一个链接。Pastebin是一个线上内容托管服务，我们可以在上面存储纯文本，如源代码片段，所形成的链接也可以分享给他人。事实上，Github gist也类似于pastebin，只是它带有版本控制。\n代码示例：\n来看一下这个file.py的python代码文件中的内容：\nfile.py\ndef foo(x):\nreturn x\n在Jupyter Notebook中使用% pastebin形成一个pastebin的链接。\n\n\n%matplotlib notebook\n％matplotlib inline函数用于在Jupyter笔记本中呈现静态matplotlib图。我们可以尝试用notebook来代替inline得到可轻松地缩放和调整大小的绘图，但要确保在套用matplotlib资源包之前调用该函数。\n\n\n%matplotlib inline vs %matplotlib notebook\n%run\n%run函数用于jupyter notebook中运行一个python脚本文件。\n%%writefile\n%% writefile将执行单元的内容写入文件。下面的这段代码将写入名为foo.py的文件并保存在当前目录中。\n\n\n%%latex\n%% latex函数将单元格内容以LaTeX的形式呈现。它对于在单元格中编写数学公式和方程很有用。\n\n\n4.发现并减少错误\n交互式调试器(interactive debugger)也是一个Magic函数，但我必须给它归个类。如果你在运行代码单元出现异常时，可以在新行中键入％debug运行。这将打开一个交互式调试环境，它将您告诉你代码发生异常的位置。你还可以检查程序中分配的变量值，并在此处执行操作。点击q可退出调试器。\n\n\n5.输出也可如此美观\n如果你想生成美观的数据结构，pprint是首选的模块。它在输出字典数据或JSON数据时特别有用。下面来看一下print 和pprint输出的一个例子：\n\n\n6.让提示更突出\n可以在你的Jupyter Notebook中使用提示/注释框来突出显示任何重要的内容。注释的颜色取决于指定的提示类型。只需在代码中加入需要突出显示的内容即可。\n蓝色提示框：注释\n代码示例：\n提示框开头\nTip:\n Use blue boxes (alert-info) for tips and notes.\nIf it’s a note, you don’t have to include the word “Note”.#提示框内容\n提示框结尾\n输出结果：\n\n\n黄色提示框：警告\n代码示例：\nExample:\n Yellow Boxes are generally used to include additional examples or mathematical formulas.\n输出结果：\n\n\n绿色提示框：成功\n代码示例：\nUse green box only when necessary like to display links to related content.\n输出结果：\n\n\n红色提示框：高危\n代码示例：\nIt is good to avoid red boxes but can be used to alert users to not delete some important part of code etc.\n输出结果：\n\n\n7.输出一个执行单元中的所有结果\n下面来看一下Jupyter Notebook格中包含的几行代码：\nIn[1]: 10+5\n11+6\nOut[1]: 17\n通常一个执行单元只输出最后一行的结果，而对于其他输出我们需要添加print（）函数。好吧，事实证明我们可以通过在Jupyter Notebook开头添加以下代码来输出每一行的结果：\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n现在所有结果可以被一一输出：\nIn[1]: 10+5\n11+6\n12+7\nOut[1]: 15\nOut[1]: 17\nOut[1]: 19\n如果要恢复成初始设定：\nInteractiveShell.ast_node_interactivity = \"last_expr\"\n8.使用‘i’选项运行Python脚本文件\n在命令行中运行python脚本的典型方法是：python hello.py。但是，如果在运行相同的脚本文件时额外添加一个 -i，例如python -i hello.py，这会带来更多好处。我们来看看是怎么回事：\n首先，一旦程序结束，python不会退出编译器。因此，我们可以检查变量的值和程序中定义的函数的正确性。\n其次，我们可以轻松地调用python调试器，因为我们仍然在编译器中：\nimport pdb\npdb.pm()\n这将把我们带到代码发生异常的位置，然后我们可以去处理代码。\n\n\n9.自动添加代码注释\nCtrl / Cmd + / 命令将自动注释执行单元中的选定行。再次点击组合将取消注释相同的代码行。\n10.删除容易恢复难\n你有没有不小心误删过Jupyter Notebook中的执行单元呢？如果有，这里有一个可以撤消该删除操作的快捷方式。\n如果你误删了执行单元的内容，可以通过点击CTRL/CMD+Z轻松恢复。\n如果你想要恢复所删除执行单元的所有内容，可以点击ESC+Z 或者 EDIT > Undo Delete Cells\n总结\n以上所列出来的是我自己目前在使用Python和Jupyter Notebook时所收集的一些重要技巧。我相信它们能帮助到你并让你学以致用。有补充的伙伴也可以大方的留言啦！\n 对Python感兴趣或者是正在学习的小伙伴，可以加入我们的python学习者聚集地，看看前辈们是如何学习的！从基础的python脚本到web开发、爬虫、django、数据挖掘等，零基础到项目实战的资料都有整理。送给每一位python的小伙伴！每天都有大牛定时讲解Python技术，分享一些学习的方法和需要注意的小细节，现在，点击加入我们的 \npython学习者聚集地\n 吧"},
{"url": "https://www.douban.com/note/720015520/", "title": "Python猫荐书系列之七：Python入门书籍有哪些？", "article": "本文原创并首发于公众号【\nPython猫\n】，未经授权，请勿转载。\n原文地址：\nhttps://mp.weixin.qq.com/s/ArN-6mLPzPT8Zoq0Na_tsg\n最近，猫哥的 Python 技术学习群里进来了几位比较特殊的同学：一位初三的以编程为兴趣的女生、一位在大学里刚开始执教 Python 的老师、一位四十多岁仍在编程一线的工程师。\n自从写公众号以来，我就遇到了各色各样的人，比如，一位代替小学生儿子来加群的牙医父亲、一位多年自由职业每天炒股的前黑客、一位来咨询课程的自学编程的听障人士……\n其实，这些人都是极少数的个例，读者里绝大部分应该都是在校学生、程序员或即将转行成为程序员的人，但是，这些身份特殊的少数人群却触动了我。\n一方面，我看到了 Python 的强大吸引力，另一方面，我也看到了 Python 学习群体的多元化。\n近些年，为什么各类培训机构会大行其道呢？也许正是因为这庞大而多元的学习人群，想要挤上通往 Python 引力中心的桥梁啊！\n我以前总是有意无意地忽略了这些读者的存在。前几天，我接了极客时间的一个专栏推广，在跟一些读者的互动中，以及在一些现象的观察中，我加深了对这些非主流人群的认识。\n意识到了这一点后，我想，或许我也能为他们做点什么？至少以后在写文章的时候，应该设法做到兼顾吧。\n正好，最近又有几位不同身份的初学者来咨询，要我推荐几本入门书籍，而我们荐书系列已经停更了两个多月，所以，本期荐书就来推荐一些入门书籍吧。\n为了准备这期荐书，我专门搜集了 40 本 Python 入门书籍，现在全部加入到了一份豆瓣豆列里，方便大家查看。\n先给大家看看完整的书单吧。\n豆列：\nhttps://www.douban.com/doulist/114507342/\n《“笨办法”学Python》  \nhttps://book.douban.com/subject/26264642/\n《python学习手册（原书第5版）》\nhttps://book.douban.com/subject/30364619/\n《Head First Python（中文版）》\nhttps://book.douban.com/subject/10561367/\n《Python基础教程（第3版）》\nhttps://book.douban.com/subject/27667375/\n《Python编程无师自通》\nhttps://book.douban.com/subject/30419778/\n《从Python开始学编程》\nhttps://book.douban.com/subject/26919485/\n《Python编程之美：最佳实践指南》\nhttps://book.douban.com/subject/30314669/\n《Python语言及其应用》 \nhttps://book.douban.com/subject/26675127/\n《Python编程：从入门到实践》 \nhttps://book.douban.com/subject/26829016/\n《像计算机科学家一样思考Python (第2版)》\nhttps://book.douban.com/subject/26870407/\n《Python编程快速上手》 \nhttps://book.douban.com/subject/26836700/\n《Python游戏编程快速上手》\nhttps://book.douban.com/subject/26868640/\n《爱上Python》\nhttps://book.douban.com/subject/26807339/\n《Python编程初学者指南》 \nhttps://book.douban.com/subject/26287445/\n《Python语言程序设计基础（第2版）》\nhttps://book.douban.com/subject/27021033/\n《Python语言程序设计》\nhttps://book.douban.com/subject/26643589/\n《Python入门经典》\nhttps://book.douban.com/subject/11610789/\n《Python入门经典》\nhttps://book.douban.com/subject/26378143/\n《Python编程导论（第2版）》\nhttps://book.douban.com/subject/30155590/\n《计算机编程导论—Python程序设计》\nhttps://book.douban.com/subject/25839870/\n《趣学Python编程》 \nhttps://book.douban.com/subject/25837145/\n《Python带我起飞：入门、进阶、商业实战》\nhttps://book.douban.com/subject/30253254/\n《Python趣味编程入门》\nhttps://book.douban.com/subject/30310729/\n《从问题到程序-用Python学编程和计算》\nhttps://book.douban.com/subject/27076220/\n《跟老齐学Python》\nhttps://book.douban.com/subject/26987889/\n《零基础学Python》\nhttps://book.douban.com/subject/26414709/\n《Python程序设计入门到实战》\nhttps://book.douban.com/subject/26958121/\n《从零开始学Python网络爬虫》\nhttps://book.douban.com/subject/27180929/\n《零基础学Python图文版》\nhttps://book.douban.com/subject/26607568/\n《教孩子学编程（Python语言版）》\nhttps://book.douban.com/subject/26773320/\n《父与子的编程之旅：与小卡特一起学Python》\nhttps://book.douban.com/subject/26005639/\n《学习Python：做个有编程能力的设计师》\nhttps://book.douban.com/subject/26590884/\n《零基础入门学习Python》\nhttps://book.douban.com/subject/26966433/\n《零压力学Python》\nhttps://book.douban.com/subject/30234139/\n《零基础学编程：树莓派和Python》\nhttps://book.douban.com/subject/30262045/\n《Python编程入门（第3版）》\nhttps://book.douban.com/subject/25773122/\n《Python语言入门》\nhttps://book.douban.com/subject/1239501/\n《可爱的Python》\nhttps://book.douban.com/subject/3884108/\n《Python编程入门经典》\nhttps://book.douban.com/subject/6846632/\n《毫无障碍学Python》\nhttps://book.douban.com/subject/27196748/\n40 本书，这份书单应该是面向 Python 初学者的最全书单了吧。\n我只翻阅过其中几本，其余的书都没看过，也不建议读者全部去读，之所以要搜集这么多，主要有如下考虑：读者面很广，而书种类不同，因此适宜多推荐。\n有些书适合完全零基础、有些书适合有编程基础；有些书面向高校学生、有些书面向小学生；有些书系统全面兼顾进阶内容、有些书简明基础适合快速上手；大部分书籍是外文翻译，少部分是国内原创；有些书是经典常销，有些书是新鲜热门；有些书偏重理论，有些书偏重实战……\n总之，总有一本适合你。\n需要声明一下，书单中都是已出版的中文书籍，都能在豆瓣上找到条目，除了这些，网上还有很多不错的入门书籍，例如《A Byte of Python》这本书的中文译本《简明Python教程》、Python 之父参与编写的《Python Tutorial》、知乎编辑整理的《编程小白学 Python》等等，无法一一罗列，但都可以作为参考之选。\n另外，以上书名的排序并不代表着推荐度的排序，已附上了豆瓣链接，建议你进入相应条目查看评分与评论，再做选择。\n我的建议是：先查阅相关介绍与评价，然后选择一两本来试读，如果阅读过程不顺畅，就换掉它，如果进展顺利的话，可以考虑再速看几本，交叉阅读，查漏补缺。\n如果你对这份书单有什么意见，例如建议补录某本书、分享对某本书的看法、补充学习资源、提供建立后续书单的建议，等等，欢迎给我留言。\n最后，告诉大家一个好消息：当当网几百万本图书正在做活动（有效期：05.25--06.03），每满 100 减 50，而我有幸拿到了定制的优惠码，两重优惠叠加，最低可享 4.3 折（满 400 减 230）。机会难得，有购书需求的同学，请点击查看 >>> \n这篇文章\n <<< 来了解使用细则。\n往期荐书回顾：\n \n第一期：《\n编写高质量代码改善 Python 程序的 91 个建议\n》\n第二期：《\nPython最佳实践指南\n》\n第三期：《\n黑客与画家\n》\n第四期：《\nPython源码剖析\n》\n第五期：《\nPython高性能编程\n》\n第六期：《\n深度学习\n》\n公众号【\nPython猫\n】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。后台回复“\n爱学习\n”，免费获得一份学习大礼包。"},
{"url": "https://www.douban.com/note/664160945/", "title": "看了这篇，再也不怕数据分析面试了", "article": "被人面试过，也面试过别人。从面试开始到结束的3个阶段详细聊聊面试中常见的问题以及如何回答准备。这3个阶段分别是：\n\n第1阶段：面试开始，逃不掉的自我介绍\n\n\n第2阶段：考察能力的技术问题\n\n\n第3阶段：面试结束时的问题\n\n\n最后，我们聊聊面试当天要注意什么，以及面试失败以后怎么办\n一、逃不掉的自我介绍\n首先，面试的开头就是自我介绍。通常面试官也会根据你的自我介绍来展开问后面的问题。比如你在自我介绍种说了一个项目，那面试官就问这个项目的细节，比如你用了什么技术，如何实现某个功能的等等。通过项目的细节来考察你某个方面的能力，因此，自我介绍非常重要。\n如果你实在不知道如何准备自我介绍，可以按下面模板准备：\n1）我是谁：一句话说清楚你哪年在哪里获得什么学位。\n2）我做过什么：按时间顺序讲下你认为做过的最好的1个或者2个项目。\n简单说下用了什么技术，最后的成果是什么。最好能有些量化的指标，比如达到了怎样的效果等等。\n注意这里自我介绍不要展开了说项目，而是从总体上介绍项目，这样做的好处是，留有余地，让面试官后面能根据你的描述展开问你这些项目的细节。不然，如果你连细节都说了，后面面试官都不知道该问你啥了，这就叫做留有余地。\n3）我想做什么：在最后说下我希望能在贵公司继续发挥我的xxx能力。\n二、考察技术能力的问题\n虽然各个数据分析师要做的事情不同，但是数据分析师最重要的3个能力却是通用的。面试过程一般会根据这3个能力来提问：\n1）数据分析工具\n2）理论知识\n3）业务逻辑\n下面分别谈下这3个能力要掌握哪些知识。\n1. 工具\n常用的数据分析工具有Excel+SQL+Python/R，有的公司要求会一种就可以，有的要求都会，所以根据你应聘职位的不同自由选择学习就可以。\n1）Excel\n需要掌握的核心技能有：\n常用函数的使用，基础图表的制作，数据透视表，vlookup\n2）SQL\n公司的内部数据存储在数据库中，作为数据分析师要能够从数据库中获取数据并进行分析。\n需要掌握的核心技能有：\n会利用SQL操作开源数据库mysql进行增加、删除、查询、修改\n存储过程\n数据库的分组、聚合、排序\n最常见的考SQL的方法给你一个虚拟的数据库表结构，然后让你按给出的条件查询出数据，并用手写的形式写出在纸上。所以面试前把常用的语句记清楚就行了。 可以买一本《SQL必知必会》放在手边，随时翻看。\n3）编程语言Python或者R\n一般情况下，这两种语言会一种就够了。如果是学习Python的话，需要掌握的核心技能：\nPython基本语法、基本数据类型、常用的数据结构、条件和循环、函数、模块\nPython数据分析的包\n（numpy, pandas, matplotlib)\n能够用python操作结构化数据，进行数据清洗，数据抽取，数据可视化等\n使用python操作数据库\n一般不会在代码上问得太细，毕竟写工作的时候不会的就用搜索引擎搜呗，面试官重要的想知道你究竟有没有用过这个技能。\n2.理论知识\n1）统计概率\n这是数据分析必须要学的，不然很多统计指标看不懂，统计方法也不了解，怎么做数据分析呢？\n需要掌握的核心技能有：\n描述性统计（平均值，标准差，中位数）\n概率（独立事件，相关事件，期望，包括贝叶斯）\n概率分布（离散概率分布，连续概率分布）\n统计推断（抽样，置信区间，假设检验）\n例如面试官可能会这样问：置信区间 （Confidence Interval） 是更怕I型错误还是II型错误？如果还不会，可以在我在知乎live的统计概率思维系列课程即可。\n2）机器学习（加分项）\n机器学习这一块其实应该算是数据分析岗位的加分项，不一定是必须的，要看具体岗位。\n需要掌握的机器学习算法：\n分类算法：逻辑回归，贝叶斯、决策树、随机森林\n回归算法：线性回归\n聚类算法：K-means\n需要掌握的核心技能：\n特征工程\n模型评价\n交叉检验（用已有的数据监测算法的预测力）\n能够熟悉常见算法的基本原理、了解各类算法的优缺点和使用场景即可，如果是学到Python，要会使用Python的机器学习sklearn包应用这些算法解决具体的问题。这方面多做几个kaggle项目可以解决：\nKaggle如何入门？\n3.业务逻辑\n主要包括业务指标和数据分析报告2块内容的掌握。\n1）业务指标\n数据分析师每天要关注大量数据指标，而数据指标又与具体的领域业务相关，掌握常用的数据指标可以灵活应对面试中提出的业务问题。\n比如面对新的数据需求，能否将它拆分成具体的指标进行计算? 各个指标如何衡量，比如app的转换率，是点击算转化还是注册了算转化还是购买产品后算转化？\n需要掌握的核心技能：\n某一领域的知识概要(只需要大致了解)\n数据分析思维：漏斗思维，分类思维，平衡思维，A/B test等\n相关性和因果关系的区别， 通过案例可以分析出来\n如何习得这方面能力呢？\n掌握常用的数据分析指标体系，可以看《增长黑客》。这个话题比较长，我后面会专门写一篇文章聊聊具体数据的分类，常用的指标体系，以及如何通过一个项目来熟练应用并向面试官展示你有这方面能力。\n2）\n如何做数据分析报告？\n数据分析的最终产出是一份份报告，可能是PPT，也可能是PDF等，或者使用python的notebook来生成。\n上面每个技能的熟练程度划分为5个等级，依次分别是：\n了解基本概念\n了解基本概念/会简单操作\n熟悉基本概念/熟练操作\n精通逻辑论证/能改进优化\n对于找数据分析师实习或者初级数据分析师的工作来说，上面这几个知识大多只需要掌握到第2个等级就可以了。\n三、面试结束时的问题\n问完上面的技术问题，到了面试快结束的环节，面试官通常会问：\n你有什么问公司的？\n这时候绝对不要问工资、五险一金和年假制度（这种是面试通过后，到了HR阶段有的是机会私下问HR）。你可以提前准备这样几个问题，比如：\n我会和谁一起工作？\n如果我遇到问题，我可以通过哪些方式获得指导？\n公司希望我在三个月左右能达到什么水平？\n在我以前，公司里最优秀的新人是什么样的？\n四、最后，猴子我和你谈谈心\n1.找工作什么时机概率最大？\n秋招（每年的10、11月份）和春招（每年的3、4月份），是各大企业招聘的黄金时期，在这个时候会涌现出大量的岗位需求，包括数据分析师。并且，由于需求的突然涌现，一般都会带来一定程度的供不应求的状态，企业也会根据需求的紧急程度来适当调整入职门槛。大部分互联网公司都在这个阶段完成招聘。\n2.面试当天要注意什么？\n穿的正常就可以，不要太与众不同。手机不要调成振动，一定要调整到无声。坐下就拿出笔记本（能写字的那种笔记本哦）。对面试官不要叫“某总”，张嘴就叫“老师”。\n简历里不写错别字。面试时一直笑眯眯。\n进入面试环节后，不要被对方牵着鼻子走，要多说你会的，你熟悉的，不会的就说没做过。这是为什么呢？因为面试的时间相对固定，你说的多了。面试官问的就少了。你暴露的几率也就低了。\n3.如果面试失败怎么办？\n1）第1种情况，简历制作太差\n如果你是转行到数据分析，是没有项目经验的，但是如果简历里面也是一片空白，连面试的机会都没有，这方面可以具体看我详细写的：\n转行数据分析，如何写简历通过的机会最大？\n2）第2种情况，找错职位了\n市面上的职位虽然名称都是“数据分析师”，但是要做的事情却是大大的不一样。面试失败，可能是你应聘的职位并不是适合你的那个“数据分析师”。\n比如之前有位\n社群会员\n是学到了入门阶段，但是去应聘一家数据分析师，要求精通机器学习，那么这种能力和职位不匹配，肯定是过不了面试的。这种情况你就要筛选出符合自己能力的职位，并看清楚职位的介绍，根据自己的能力来找到适合自己的工作。\n所以，如果面试被拒也不要气馁，有可能并不是你的原因，只是与岗位要求不匹配。\n现在已经\n转行成功的社群会员insight\n是这么分享他找工作中犯的一个错误的：\n收到面试通知时，没有问HR在公司数据分析职位是做哪些工作或是用什么分析工具。我投递简历选择的是拉勾网和BOSS直聘，前两天很认真的投递了简历，也收到了三家金融公司的面试，但一了解是让做金融交易员的，瞬间心脆。\n三天过去还有合适的公司，就有点心慌了，于是看到职位描述上有EXCEl和Mysql相关技能的，我都投了一份简历。没有针对性，也是犯了效率不高的错，这个错误等下说，重要的是收到面试通知时，没有问清HR数据分析工作是用什么分析工具或者主要是做什么工作。\n我去北京第一家公司面试的时候，就是奔着他们的职位描述去的，当时想就是自己要的工作，但去了之后，HR说他们公司只用EXCEL做数据分析，公司慢慢的会有数据团队。\n还有另外一家做大数据的公司，面试的时候出的是这样的题目，问题1:tensorflow构建一个神经网络的步骤；问题2：试用scikit-learn实现一个简单的线性回归模型(这个记不太清了)，全都是诸如此类的问题。\n所以说，如果提早的询问下，就会减少不必要的麻烦，可以多面试几家相符的公司。\n3）第3种情况，面试失败是中常态\n记住，面试是个长期的过程，很可能你投递简历很长时间没有人联系你，突然有一天电话就来了。这时候考察的就是谁能坚持到最后，一边积极等待投简历，一边积极准备技术。\n失败的面试不代表你不行，而是你和公司不适合。这就好比谈恋爱，双方互相看对眼了才能双宿双飞。\n动感单车健身公司飞轮运动（Flywheel Sports）的CEO欧哈根，她曾在30岁之前两次被公司开除。所以几次失败，不要否定自己。学会拥抱失败。你经历的每件事情都会给你收获，所以在经历这些时不要压力太大。而且人生不止一次机会。\n如果面试失败就去看《当幸福来敲门》，学会鼓励自己。再不行，就多看看这些经过多次失败，但是最后转行成功的朋友。记住，你并不孤单。\n4）第4情况，还没准备好\n如果到最后经过N多次面试，并且排除了前面几种情况的可能，那么你已经总结好了面试中哪些能力是自己没有准备好的，那么你后面就可以多花些时间在这些欠缺的地方花更多时间去弥补上。等准备好了，再去应聘。有时候，人生比的不是谁跑的更快，而是谁能跑到终点。因为，有很多人没到终点，就放弃了。\n同时，如果是转行数据分析，因为没有工作经验被拒的话，也可以通过测试、运营、产品、等岗位曲线救国。\n因为互联网公司的测试岗位，空余时间多，你可以有更多的时间来同时学习数据分析方面的知识，还赚取了互联网工作的经验。而运营、产品工作中要经常跟数据打交道，不仅能熟悉公司的业务，还能接触到数据，后期合适的机会不管是进行内部转岗到数据分析部门，还是再找数据分析的工作会比较有优势。\n最后，祝你成功。每个人生下来都是猴子，可有些人却最终可以逆袭为悟空。所以每个人心中其实住了个大圣。齐天大圣是不会死的，他只是睡着了。有一天，你要是够坚强，够勇敢，就能驾驭它。\n如果有什么需要帮助的可以在留言区提问，我会尽力帮助到你。\n推荐：\n猴子教你如何准备一份数据分析师简历的清单"},
{"url": "https://www.douban.com/note/751921269/", "title": "网易云热歌都唱了什么？记一次python练习", "article": "网易云热歌都唱了什么？记一次python练习\n关键词：数据可视化、数据分析、Python爬虫\n原文：\n 点击\n一\n最近在学python，虽然还只是一点皮毛，但终于可以做做自己的小项目了。学习任何一门语言的最好方法就是实践，能完成一个小项目，还是很有成就感的。\n这次我想知道，网易云的热门歌曲都唱了什么。\n想要获得热歌，我的第一个想法是可以爬爬网易歌单，幸运的是，网易云有一个歌单（云音乐热歌榜）专门收录当下的热门歌曲。\n而想知道唱了什么，则可以从歌词入手，在歌单页面下有一个列表，每一个歌名都有链接，可以通过循环的方式获取每一个歌曲页面，并想办法获得歌词信息。因为无法直接在歌曲页面上爬取歌词，就需要寻找网易云的api，还好，这个也没花太久时间。需要注意的是，每一个歌曲都有唯一的id，可以通过这个id来指定歌词的链接。最后爬取的结果是一张表，有200首歌曲，涵盖的信息分别为id、歌名、链接、歌词，保存为csv到本地。\n这个项目一共用到这些库：\nBeautifulSoup、lxml、requests、wordcloud、pkuseg、matplotlib、re、pandas。\n其中BeautifulSoup、lxml、re用于网页解析或字符匹配，requests用于获取网页，pandas用于数据处理，wordcloud库用于制作词云，pkuseg用于分词，matplotlib用于加载图像。\n从上面的思路出发，我先写了一个爬虫脚本。\n爬虫写好后，再写一个主程序，就可以运行爬虫，下载歌单信息。\n保存的csv大概是这样的:\n接下来写了数据可视化的程序。\n最后用主程序把爬虫和数据分析链接起来。经过好一番调试，终于跑了起来。\n以下是实验的结果，生成的词云均通过停词表过滤。\n可以看到排名靠前的词中有非常多感染力强的的拟声词或语气词，这里列举一下：\ndoo、oh、ya、da、yeah\n为啥da这个词会这么多呢？查看文件发现了这么一首歌：\n...\n这也许说明热门歌曲之所以热门，是因为其歌曲含有许多较为原始的发声吧，而这些发声虽然原始却很能引人注意，带动情绪。\n那么除去了这些语气词后呢？\n可以看到，“baby”和“世界”是出现最多的，其次还有“时间”、“爱情”、“也许”、“未来”、“离开”。\n至于有什么含义，我也没有太好的想法，大家自由发挥吧，欢迎留言评论。\n前20词汇排名：\n二\n在完成上面的小项目后，我又不满足于此了。我想获得更多歌曲的信息。\n通过网易云歌单搜索可以获得歌单列表，这是歌单的歌单。如搜索“摇滚”，将会得到成千上万条歌单结果，并且是按照收藏人气排名的。通过网易云api搜索歌单列表，得到一个保存歌单的表，再通过上文方法循环爬取数据。最终可得到上万首歌曲歌词信息，不过需要注意的是，同一首歌可能出现在不同歌单里，因此出现重复歌曲时选择跳过。\n最后所有参数在settings.py里设置，以方便多测试几个类别。我终于可以知道“摇滚”、“民谣”、“说唱”都唱了什么了。\n以下是我实验的结果。\n摇滚\n爬取了“摇滚”歌单搜索结果的前50个歌单（按收藏人气排名），一共有6215首歌，其中无歌词的歌曲有478首，因此有效数据为5737首。\n去语气词后：\n看来“时间”和“爱”是摇滚里出现最多的，此外还有“baby”、“回来”、“生活”、“感受”、“心”、“夜晚”，这是英文的语境。中文歌词不太明显，我们之后做进一步处理。从表中看去，“爱”的频次明显高于其他，不得不说，搞摇滚的对\n爱\n真的很执着。\n前20词汇：\n我想了解中文歌曲的情况，因此尝试在原有基础上去除英文词汇：\n日文我看不懂，机器翻译又有失准确性，还是略过好了。\n“时间”和“世界”排在前，其次是“离开”和“生活”。\n我特地看了“离开”的语境，发现大多是描述人与人之间的离开：\n而“生活”则是各种各样的，“生活”太丰富，这里太挤就不举例的。\n他们在“等待”，查看歌词才发现绝大多数都是在等待着某人。\n他们谈论了许多次“未来”，又害怕“忘记”自己，忘记了对方和方向。怀揣“希望”又或者只是“希望”着什么，身处“城市”里感受“孤独”。\n他们关心“生命”，也像每一个摇滚的人一样，关心“天空”和“自由”，却对明天有着不一样的看法，有的乐观，有的充满疑惑。\n民谣\n爬取了“民谣”歌单搜索结果的前50个歌单（按收藏人气排名），一共有6506首歌，其中无歌词的歌曲有564首，因此有效数据为5942首。\n未去语气词的词云：\n过滤语气词后的词云：\n民谣歌里提到了最多次“世界”和“love”，“姑娘”居然能排在第四的位置，根据我直男的第一反应，唱民谣的肯定大都是大老爷们，而且还是很想要交女朋友的那种。\n从结果中可以看出，与时间有关的词汇非常多，有“时间”、“时光”、“回忆”、“永远”、“岁月”、“记得”，在词云中还可以看到“忘记”、“日子”、“匆匆”、“消失”、“未来”、“从前”、“遗忘”、“忘记”。看来歌手对于时光也有一些执着，有的人想忘记，有的人却在努力回忆，他们很在乎“故事”。他们似乎有许多不太确定的想法，说了比别人多得多的“也许”。\n表达离别的词汇“离开”和“再见”出现了很多次，后来他们心中有了“远方”、“城市”、“地方”、“南方”和“北方”，他们在“生活”，感受着情绪，有“快乐”也有“悲伤”，有时“微笑”，但也时常“沉默”，甚至一个人流“眼泪”。更多时候，只是“孤独”、“孤单”、“寂寞”，多么渴望“温柔”，渴望一个“拥抱”。\n他们提到了很多很多次“爱情”、还有“喜欢”的人和东西。也许民谣就像这样，明明唱着歌，却好像和你聊了一次家常，讲了讲一些有趣或伤感的故事。\n说唱\n爬取了“说唱”歌单搜索结果的前50个歌单（按收藏人气排名），一共有11438首歌，其中无歌词的歌曲有7374首，有效数据为4064首。\n未过滤语气词的词云：\n看起来还好，就是不容易找到重点，那么过滤语气词之后呢？\n“love”是最多的，其次是“baby”、“back”，无论中英文，也无论歌曲的种类，大家似乎都对“时间”很关心。“感觉”出场了，“man”和“girl”几乎一样多。\n去除英文内容后的词云（虽然不是很干净）：\n（尽量）去掉英文常用词后，出人意料的是有一些中东歌曲乱入了，大家忽略就好。中文里“时间”和“世界”仍然出现最多次，其次是“真的”，如何理解？先不慌想这个，我们看看其他词。\n看看“想要”、“生活”、“喜欢”、“希望”、“不用”，还有“老子”、“兄弟”，以及那些密密麻麻卡在缝里的关键词，如“都会”、“只能”、“放弃”、“别人”、“习惯”、“不停”、“从不”、“从来”，让人觉得这是一群有些憋屈却仍然逞能的年轻人在唱着自己的主张，然而在说唱里，直接提到“爱情”却比民谣要少得多。\n说回来“真的”这个有些奇妙的词，我去翻了翻歌词，结果是这样的：\n个人理解，词“真的”在情绪较强烈、或表强调的时候使用，所以在说唱中为了起到强调的效果，就不知不觉地用多了，我真的是这样想的。\n除了“真的”，就是“想要”了：\n“想要”是一种明确表达欲望的说法，看来歌手“想要”让大家都知道他的想法，是一种主动的表现。\n \n最后，我们来一次横向比较：\nemmmm，看起来生活、时间、世界均稳居前列，不如我们把这三者加入停用词，看看之后会有什么结果。\n摇滚\n民谣\n说唱\n你发现什么了吗？还请留言评论。\n三\n分词和词云的效果与文本清理、分词工具有关。文本清理要注意去掉多余的符号，还要去掉多余的空格，尤其是在生成词云之前。分词结果直接影响词云效果，要选择合适的分词工具，之前测试了jieba，始终效果不太好，后来改用北大开发的pkuseg，效果要好一些，分词性能也更高。\n在写代码的过程中，有一些经验教训也总结总结吧。\n关于爬虫：\n在获取歌词的函数中，见\nget_lyric()\n，要考虑到歌词不存在的情况，如果歌词不存在直接跳过，会造成csv表项目不匹配，导致尾部数据缺失。虽然考虑到了，若直接设为空值，后果则是默认属性将为{float}NaN，浮点数空值。歌词项应该统一为str，若中间穿插其他类型，将为后续造成许多麻烦。\n关于Python：\n.remove()\n与\n.append\n分词时，有一个过滤常用词的操作，开始时不懂，去掉常用词直接用的\n.remove()\n，后来才发现这严重影响性能，文本越大，性能影响越大。可以另定义一个列表，用\n.append()\n操作。我估计用\n.remove()\n操作时需要移动列表之后的每一个元素，复杂度直接指数增加了。\n关于正则表达式：\n在使用正则表达式替换字符时，或运算不宜太多，不必要的或运算可以转为其他方式处理，比如无效词/字符可以放入停用词表处理。\n关于使用停用词表：\n要特别注意英文单词有大小写形式，最好保证停词表统一为大写或小写，在词语匹配的时候分词要相应的用\n.upper()\n或\n.lower()\n形式。\n关于工具使用：\n使用wordcloud库的时候没认真看文档，入了一个坑，使用\n.generate()\n生成的词云不一定按照词频处理，有些词频高的词语反而无法显示或显示较小，这是库算法自行决定的，若要按照词频生成词云，需要用\n.generate_from_frequencies()\n方法。可以用tabulate打印markdown表格。\n代码已经放在Github上了，感兴趣的同学可以点击阅读全文查看。\n \nhttps://github.com/OhiyoX/NeteaseMusic-Lyric-Analysis"},
{"url": "https://www.douban.com/note/698533783/", "title": "孤荷凌寒自学python第二十三天python类的封装", "article": "孤荷凌寒自学python第二十三天python类的封装\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n一、从怎么样访问类的内部代码块中定义的私有属性说起\n类中定义的私有属性和私有方法是无法被外部代码块访问的，就算是类的继承类也无法访问基类（父类）的私有对象。\n然而这却并不是绝对的说法，其实python语言灵活地留了一手，是可以直接使用点语法访问类的私有对象的！\n测试：\nclass cup(object): #作为基类\n__private='我是cup类的私有属性' #私有属性\npublic='我是cup类的公开属性'\none='我是cup类的第一属性'\n__two='我是cup类的第二属性' #私有属性\ndef __init__(self,one,two):\nself.one=one\nself.two=two\ndef publicmethod(self,var1,var2):\nreturn \"cup类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self): #私有方法\nreturn '这是cup类中的私有方法打印的内容。'\ndef __倒掉水(self): #私有方法\nreturn '这是cup类执行了【倒掉水】的方法。'\nclass glass(object): #作为基类\n__private='我是glass类的私有属性' #私有属性\npublic='我是glass类的公开属性'\none='我是glass类的第一属性'\n__two='我是glass类的第二属性' #私有属性\nthree='我是glass类的第三属性'\ndef __init__(self,one,two,three):\nself.one=one\nself.two=two\nself.three=three\ndef publicmethod(self,var1,var2):\nreturn \"glass类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self): #私有方法\nreturn '这是glass类中的私有方法打印的内容。'\ndef __碎掉(self): #私有方法\nreturn('glass类的实体化对象执行此方法后，碎掉了。')\nclass cupglass(cup,glass): #继承自cup类和glass类而实现双重继承的子类\npass\nnewobj=cupglass('玻璃','蓝色') #因为定义cupglass类时，基类列表是有顺序的，基类cup在列表最前面，优先级最高，因此以它的初始化方法函数 的参数个数为准\nnewobj2=cupglass('陶瓷','白色')\nstr1=newobj._glass__碎掉() #访问类中私有对象的方法是：一根下划线 加上 最初定义方法函数的类名 加上 私有对象名。\nstr2=newobj2._cup__倒掉水()\nstr3=newobj._glass__private\nstr4=newobj._cup__private\nprint(str1)\nprint(str2)\nprint(str3)\nprint(str4)\n运行结果 ：\nglass类的实体化对象执行此方法后，碎掉了。\n这是cup类执行了【倒掉水】的方法。\n我是glass类的私有属性\n我是cup类的私有属性\n小结：\n类中的私有对象其实也是可以通过点语法直接访问的，方法是：\n实例化的对象名\n . \n_最初定义私有对象的基类名私有对象名\n测试中的例子：\nstr2=\nnewobj2\n . \n_cup__倒掉水()\n【最初定义私有对象的基类名】的解释：\n实例化后的对象：newobj2 是 cupglass 类的实例化对象。\n而cupclass 类 继承自两个 基类 cup glass .\n要调用的私有对象 __倒掉水() 本质上不是由 cupglass类亲自 定义的，\n而是cupglass 类从 cup 类中继承而来,事实上由cup类亲自定义的，\n因此我们在这儿写的【最初定义私有对象的基类名】就只能写：cup而不是写 cupglass。\n二、真正正确地访问类中私有对象方法是通过类的封装来实现\n虽然第一点的方法可能访问到类的私有对象，但其实并不安全，会对类的内部对象造成干扰，如果操作不当，类的实例化对象的稳定性就会受到影响。\n因此 真正正确的做法是，通过在类的内部代码块中 封装好对各个 私有对象的访问方法。\n关于封装的测试：\nclass clsTwo(object):\n__width=0 #全部属性都被定义为了私有属性。\n__wide=0\n__height=0\n__color=0\n#下面定义类的初始化方法\ndef __init__(self,width,wide,height,color):\nself.__width=width\nself.__wide=wide\nself.__height=height\nself.__color=color\n#下面开始封装方法函数的定义，通过下列封装方法函数来间接取得和设置 类中 各个 私有属性的值\n#得到__height的封装方法函数\ndef getheight(self):\nreturn self.__height\n#设置__height值的封装方法函数\ndef setheight(self,height):\nself.__height=height\nobj=clsTwo(100,80,60,'red') #得到类clsTwo的一个实例化对象\nintHeight=obj.getheight() #调用类的公开封装方法来获取__height\nprint(intHeight)\nintHeight=intHeight+100\nobj.setheight(intHeight) #调用类的公开封装方法来设置__height\nintTemp=obj.getheight()\nprint(intTemp)\n运行结果：\n60\n160\n通过封装后，外部代码将不会直接访问和操作类的实例化对象的属性，全部通过类的公开方法来进行，提高了代码安全性。\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1kv77Tjel4PtfFScYe2qgXw\n  密码：2zc5\nBilibili:\nhttps://www.bilibili.com/video/av36211235/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/140726943"},
{"url": "https://www.douban.com/note/745019276/", "title": "我的Python梦--前半生自述", "article": "深圳的十一月天，不同于我待过的任何一个城市，气候温润，温度适宜。习惯了北方的我，也就只有在这种环境下，才会打心里喜欢上这座城市。\n\n \n说说我的前半生\n这个话题，说着会有点沉重。前半生，好像这个词只有那些已经成家立业的人才会去谈及的吧。而我，一个24岁的深漂少年，却也想说说自己的前半生。\n当一个人真正具有独立思考能力的时候应该才是其人生的起点吧\n，那么对我来说，我的前半生应该从大学算起了。\n普通一本，计算机专业，对编程一张白纸的我在刚入学就对代码充满了热情。\n直到第一学期末，拿到课程设计优秀的我也是第一次有了一种相见恨晚的感觉。加入学习小组，一起参加比赛，更是让我对编程的热爱更加浓烈。\n像我这样的人，就该这条路走到黑吧。\n大学对于我最有影响的两件事，一个是编程，一个就是考研。编程让我找到了自己钟爱的东西，而考研带给我的是性格的磨练。\n早起五点图书馆排队，晚上十一点路灯下背书，甚至通宵复习第二天只睡三个小时。没有经历过，你可能不会感同身受，最多在心里说一句“流弊”。\n但当我回顾整个考研历程时，最最深刻的是我自己的一些行为已经潜移默化的改变了。\n我可能让自己完全静下心来只需要五秒，甚至可以在图书馆看完一整本工具书，更会在自己一个人的时候也可以去旅游，可以面对陌生的领域也知道怎么去深入挖掘，可以做自己以前想做却不敢一个人做的事，可以学一个新的知识而不需要有人带。虽然最终考试结果差强人意，但能让我改变这么多，也算是一种收获吧。\n在工作之后，发现自己有时候却也做不到当初那样独立与上进。想做公众号很久，但是由于依赖心里想着找几个朋友一起，没找到志同道合的不说，最终还耽搁了挺久。\n想想自己做公众号的初衷，现在也能为自己迈出的这一步而感到庆幸。\n还好我没放弃，还好梦想还在。\n记得刚开始的时候，想着公众号写一些自己的学习经验、生活感悟和人生理想，现在，我也在努力迈出第一步。\n自己这两年除了做一些小开发之外，最多的是在做数据分析，同样也认识很多一起做分析的朋友。对于科班出身的我，可以在没看过Python一张一页的情况下，三天入门Python并且上手数据分析，这可能对于没有基础的你们有点小困难。\n如何快速上手学习Python，这，也是我准备送给你们的第一个小礼物。\n我会从最基础的开始介绍，会从Python入门语法一节节介绍，从进阶到高阶；会从爬虫一步步的记录，从数据爬取到数据保存，从单机到分布式；会从可视化一个个图形介绍，从单图到多图，从静态到动态。最后会从数据分析慢慢上手，从个人编程技巧到完整项目实践，可能并不是一个全面的学习路径，但却是我个人总结的最直接的学习方式。\n其实写的这么多，也是希望志同道合的你一起学习交流。\n在这个\n培训机构遍布且四处喧嚣的环境里，希望在这里你能静下心来，学习Python，我们不是说说而已。\n最后\n愿我不辜负自己，不辜负你们。\n愿你们，能一手Python，走遍天涯。\n后记\n在此写一下自己的学习历程，也是以后的更新历程：\nPython入门 — Python进阶 — Python高阶\n爬虫入门 — 爬虫进阶 — 爬虫实战\n可视化入门 — 可视化进阶 —可视化实战\n数据分析技巧 — 数据分析实战\n数据挖掘入门 — 数据挖掘进阶 — 数据挖掘实战\n \n文章中若有不足烦请指正，也欢迎志同道合的你们一起加入交流学习。\n如果你想和我一样，请关注我\n如果你也和我一样，请点赞我\n谢谢"},
{"url": "https://www.douban.com/note/726848051/", "title": "PYTHON 笔记", "article": "数据类型：\n1、整数 int  如：8\n2、浮点数 float  如：8.8\n3、字符串 str  如：''8'',''Python''\n4、布尔值 bool  如：True False\n求类型：type()\n转换类型：int('8')---8、str(123)---'123'、bool(123)---True、bool(0)---False\n变量：\na=123 \nb=a\na为变量名称（字母和下划线开头）\n==为变量赋值\n123为变量得到的值\nb=a=123\n***网络宽带计算器：\n速度 比特 bit\n存储 字节 byte\n程序扩展名*.py\n#print(100/8)\nbandwidth=100\nration=8\nprint(bandwidth/ration)\n序列：（字符串、列表、元组三种类型属于序列）\n字符串''abcd''\n列表[0,''abcd'']\n元组(''abc'',''def'')\n***计算生肖：\nchinese_zodiac=''鼠牛虎兔龙蛇马羊猴鸡狗猪''\nyear=2020\nprint (chinese_zodiac[year%12])\n序列基本操作：\n#print（'狗' in chinese_zodiac）---True\n#print（'狗' not in chinese_zodiac）---False\n#print（chinese_zodiac+chinese_zodiac）---鼠牛虎兔龙蛇马羊猴鸡狗猪鼠牛虎兔龙蛇马羊猴鸡狗猪\n#print（chinese_zodiac+'abcd'）---鼠牛虎兔龙蛇马羊猴鸡狗猪abcd\n#print（chinese_zodiac*3)---鼠牛虎兔龙蛇马羊猴鸡狗猪鼠牛虎兔龙蛇马羊猴鸡狗猪鼠牛虎兔龙蛇马羊猴鸡狗猪\n#print (chinese_zodiac[0:4])---鼠牛虎兔\n#print (chinese_zodiac[-1])---猪\n***计算星座：\n#zodiac_name=(u'摩羯座',u'水瓶座',u'双鱼座',u'白羊座',u'金牛座',u'双子座',\nu'巨蟹座',u'狮子座',u'处女座',u'天秤座',u'天蝎座',u'射手座',)\n#zodiac_days=((1,20),(2,19),(3,21),(4,21),(5,12),(6,22),\n (7,23),(8,23),(9,23),(10,23),(11,23),(12,23))   \nmonth=int(input('请输入月份：'))\nday=int(input('请输入日期：'))\nzodiac_day=list(filter(lambda x: x<=(month,day),zodiac_days))\nzodiac_len=len(list(zodiac_day))%12\nprint(zodiac_day)\nprint(zodiac_name[zodiac_len])\n添加移除列表\na_list=['abc','xyz']\na_list.append('x')\nprint(a_list)---['abc','xyz','x']\na_list.remove('x')---['abc','xyz']\nIF\nchinese_zodiac=''鼠牛虎兔龙蛇马羊猴鸡狗猪''\nyear=int(input('请用户输入出生年份'))\nif(chinese_zodiac(year%12））=='狗'：\nprint('狗年运势')\nFOR\n1、chinese_zodiac=''鼠牛虎兔龙蛇马羊猴鸡狗猪''\nfor cz in chinese_zodiac\nprint(cz)---鼠牛虎兔龙蛇马羊猴鸡狗猪\n2、chinese_zodiac=''鼠牛虎兔龙蛇马羊猴鸡狗猪''\nfor i in range(1,13)\nprint(i)---123456789101112\n3、chinese_zodiac=''鼠牛虎兔龙蛇马羊猴鸡狗猪''\nfor year in range(2000,2019):\nprint('%s年的生肖是%s')%(year,(chinese_zodiac(year%12）))\n---2000年的生肖是龙。。。\nWHILE\n1、num=5\nwhile true：\nnum=num+1\nif num>10\nbreak---aaaaaa\n2、num=5\nwhile true：\nnum=num+1\nif num==10\ncontinue\nprint(num)\ntime.sleep(1)---67891112...."},
{"url": "https://www.douban.com/note/697234936/", "title": "孤荷凌寒自学python第十二天python字典类的其它操作", "article": "孤荷凌寒自学python第十二天python字典类的其它操作\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n今天继续对dict类进行研究\n一、删除dict对象中的所有元素\ndictname.clear()\n此方法将删除dict对象中的全部元素，但字典对象本身还在。\n二、关于建立dict的副本，即创建一个dict对象的复制品。\n与之前学习到的list的副本创建一样，也分为两种情况：\n一种是创建dict的副本后，两个对象指向内存中的同一个地址，修改两个dict对象中的任意一个，都会同时修改两个dict对象的内容。\n另一种是创建dict的副本之后，两个对象有各自独立的内存地址，修改其中任意一个dict对象都一会对另一个dict对象有影响。\n我的理解是，第一种创建副本方法称之为：浅复制\n第二种创建副本的方法称之为：深复制\n1浅复制\n直接赋值\n新字典对象=原有字典对象\n2 深复制\n新字典对象=原有字典对象.copy()\n例：\n>>> print(dictA)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictB=dictA #浅复制\n \n>>> print(dictA)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> print(dictB)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictB['姓名']='张三'\n \n>>> print(dictB)\n \n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> print(dictA)\n \n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictC=dictA.copy() #深复制\n \n>>> print(dictC)\n \n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictC['性别']='女'\n \n>>> print(dictC)\n \n{'姓名': '张三', '性别': '女', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> print(dictA)\n \n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n三、补充一种创建一个字典对象的方法：通过dict类的共享方法fromkeys()来创建\n新的字典变量=dict.fromkeys(tplKeys[,oneValue])\n等号右边dict是dict类名（或也叫命名空间？）\nfromkeys是类dict中的一个未经实例化就可使用的共享方法（python中是否是这样称呼的？）\n参数tplkeys是一个包含所有需要用到的key名称作为元素组成的元组。\n可选参数oneValue如果不指定，那么新建的字典的所有元素中每个key对应的value都是None\n如果指定oneValue，则表示每个key的value都一样，都是参数oneValue表示的值。\n例：\n>>> tplKey=('张三的成绩','李四的成绩','孤荷凌寒的成绩')\n>>> dictA=dict.fromkeys(tplKey)\n>>> dictC=dict.fromkeys(tplKey,90)\n>>> print(dictA)\n{'张三的成绩': None, '李四的成绩': None, '孤荷凌寒的成绩': None}\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 90}\n四、读取字典中指定key名称元素的value\n1 第一种方法，直接访问读取\n字典对象[keyname]\n将直接返回对应keyname名称的元素的value.\n当没有在字典中找到对应的keyname名称的元素时，将产生错误！\n2第二种方法，使用字典对象的get方法\n字典对象.get(keyname[,default=None])\n参数 keyname是指字典元素中的键名；\n可选参数default=None,表示 如果在字典中没有找到对应keyname名称的元素时，就返回此defalut参数指定的默认值。\n此可选参数并不是关键字参数，书写时不能如格式上那样写成：default=None这样的格式，而比如说应当只能写None.\n此时不会报错。\n3 第三种方法，使用字典对象的setdefault方法\n字典对象.setdefault(keyname[,default=None])\n经实际测试，此方法与get方法没有区别。\n唯一的不同在于：\n如果在字典对象中没有找到对应的keyname名称的元素——\nget方法只是返回可选参数default指定的value值，但不会对字典对象的内容作任何修改。\nsetdefault方法在返回可选参数default指定的value值后，还会将新指定的keyname添加到字典中去，并设置对应value为default指定的value值。\n测试：\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 90}\n>>> intVale=dictC['张三的成绩']\n>>> print(intVale)\n90\n>>> intValue=dictC['王五的成绩']\nTraceback (most recent call last):\nFile \"<pyshell#12>\", line 1, in <module>\nintValue=dictC['王五的成绩']\nKeyError: '王五的成绩'\n>>> intValue=dictC.get('王五的成绩')\n>>> print(intValue)\nNone\n>>> intValue=dictC.get('王五的成绩',99)\n>>> print(intValue)\n99\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 90}\n>>> intValue=dictC.setdefault('王五的成绩',100)\n>>> print(intValue)\n100\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 90, '王五的成绩': 100}\n五、吞并另一个字典的所有元素\n字典对象的update()方法可以将另一个字典的所有元素追加到自己的末尾。\n当前字典.update(另一个字典)\n执行此方法后，当前字典的元素增加，所增加的元素为另一个字典中的全部元素。而另一个字典的内容没有任何变化。\n如果存在两个字典的部分元素的key值相同，则用另一个字典中的同名的key值元素的value来覆盖当前字典。\n测试：\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 90, '王五的成绩': 100}\n>>> dictD={'孤荷凌寒的成绩': 75,'赵六的成绩':85}\n>>> dictC.update(dictD)\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 75, '王五的成绩': 100, '赵六的成绩': 85}\n六、获取字典的嵌套元组列表方式的表示形式\n测试：\n>>> print(dictC)\n{'张三的成绩': 90, '李四的成绩': 90, '孤荷凌寒的成绩': 75, '王五的成绩': 100, '赵六的成绩': 85}\n>>> lstC=dictC.items()\n>>> print(lstC)\ndict_items([('张三的成绩', 90), ('李四的成绩', 90), ('孤荷凌寒的成绩', 75), ('王五的成绩', 100), ('赵六的成绩', 85)])\n七、获取字典中所有元素的key，并作为列表返回\ndictname.keys()\n此方法将返回字典中所有元素的key组成的一个列表对象。\n测试：\n>>> dictTemp={'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> print(dictTemp)\n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> lstKey=dictTemp.keys()\n>>> print(lstKey)\ndict_keys(['姓名', '性别', '身高', '体重', '职业', '爱好'])\n八、获取字典中的所有元素的value，并作为一个列表返回\ndictname.values()\n此方法将返回字典中所有元素的value组成的一个列表对象.\n测试：\n>>> print(dictTemp)\n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> lstValue=dictTemp.values()\n>>> print(lstValue)\ndict_values(['李四', '男', '180', '74', '经理', '书法'])\n九、将第七、八点获取到的key列表和value列表又重新组合成字典\n要通过zip函数将两个列表进行表格生成后，再使用dict函数转换为字典。\n具体做法测试如下 ：\n>>> print(lstKey)\ndict_keys(['姓名', '性别', '身高', '体重', '职业', '爱好'])\n>>> print(lstValue)\ndict_values(['李四', '男', '180', '74', '经理', '书法'])\n>>> dictNew=dict(zip(lstKey,lstValue)) #这是真正执行此操作的语句\n>>> print(dictNew)\n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1N_WrQuQEfBrW0x23hlb0Ug\n  密码：jvul\nBilibili:\nhttps://www.bilibili.com/video/av35778604/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/137845447"},
{"url": "https://www.douban.com/note/695915131/", "title": "不作伪分享者决定完整分享我自学Python3的全部过程细节", "article": "不作伪分享者决定完整分享我自学Python3的全部过程细节\n\n\n我不要作伪分享者\n\n\n十六年前我第一次见到了电脑，并深深地爱上了它；\n十二年前我第一次连上了网络，并紧紧地被它爱上。\n十年前的网络是田园美景的时代，里面的一个个都是菩萨；\n十年后的网络是武林争霸的江湖，湖中的一个个都是高手。\n我，一个小小的我，一个无足轻重的我，如一粒尘土飘落到这江湖水面上，激不起半点水花，荡不开一丝涟漪。\n然而江湖之下，处处暗河，时时旋涡，套路连着套路，引流连着引流，偌大一个江湖啊，菩萨们都到哪儿去了呢？\n不知是有意还是无意，这网络江湖里多数的教程与分享都不够完全与完全免费，也不是真正的无私与无私开源，一切都在拉扯着我这小小一粒尘埃，涛声高叫着——“到我这儿来吧！我们有最少的收费，并且会少讲几句洗脑的空话！”\n于是我把这一切都叫做“虚伪的分享”，只是如猪笼草甜美的诱饵，我才不愿踏入那瓶口之下的陷阱，因为时间是如此的珍贵，哪能如此听由那些骗取钱财的花言巧语。\n我要的是只留下干货的的湖中岛屿，真正的菩萨所居的圣地。\n我也愿意作一个真正的分享者，细致/全面/详尽，尽我所知，极我所能。我不要作一个伪分享者。\n我愿意终身学习只是为了不愿老去的梦想\n如我过去的博文所言，一个出生卑微，学历低下的我，仅仅凭借着区区一腔莽夫之勇，坚持学到今天，一点见识肯定谈不上有任何比旁边任意一个专业的高手们要好一星半点的地方；\n如我今天的恍然大悟，一个晚熟傻帽，头脑愚钝的我，仅仅因为着傻傻不懂嘲弄讥讽，坚强走到今天，一把年纪自然说不上有任何比无数新生青年才俊的少年们精神一丝半毫的所在。\n然而，我当然要学下去，这世间我所向往的一切，我所惊叹的所有，我都愿意去学习！\n年纪不过是纸上的一个数字，如果我不认为它有任何意义，那么它就不会有任何意义，直到那永生的死神来找我的那一天，我都不会在乎这数字有多么的庞大。\n是的，我愿意学，终身的学，不讲代价的学，然后，分享所得，接受批评，哪怕是蹒跚而行，伏地而爬，我决心不改。\n也许我卑微到无人知晓如一粒尘埃；\n也许我愚钝到身无分文欲劳碌一生。\n可是这世界的意义并不在于我将拥有多少让别人所眼红的东西，而在于我这数十载的人世游历我经历的所有见闻与所得，这才是我想要的。\n为了一个不愿老去的梦想而将终身学习的我，你们愿意与我一路同行吗？\n作了好久准备终于开始学习Python\n其实我已经比较熟练地掌握了其它编程语言了，也在日常生活中写过很多的方便自己工作与生活的实用软件，我也在问自己，一把年纪了，都到了程序员被退休的年龄了，还想到要学习一种新的编程语言，不是自己折腾自己吗？\n是的，如果一个人准备当一辈子码农，必定是凄惨的，到底也只是辛苦谋生而已，怎么谈得上学习的快乐呢？更何况我一个业余的爱好者而已，看来以此为谋生也是难为之事罢。\n我当然不是为了将Python学习到出神入化，因为我也根本做不到，纵然我有天大的梦想飞在上空，但没有学识的翅膀，我也飞不上去啊。\n然而我还是决定学习Python。\n过去一年多，我花了相当长的时间来了解python，真正吸引我是的人工智能部分，可叹一个没有进过大学校园的我，一个苟且存在社会底层的我，根本没有知识的基础来建构起我所梦想的那个人工智能的大厦。\n我也曾挣扎、痛苦，扼腕叹息……\n我开始拼命的学习一切我所不知道的未来的知识，妄图看到那个必然到来的可怕未来，终于我觉得我看到了它——\n因为今天它——人工智能已经到来！\n我不知道这片网络的江湖中，有多少文章已经不再是出自与我一般活生生的血肉之躯？\n我不知道高手林立的自媒体，有多少媒体已经不再是来自与我一般慢吞吞的血肉之躯？\n我不知道风起云涌的商海中，有多少团队已经不再是源自与我一般轻飘飘的血肉之躯？\n那些个人工智能，它们正无所不在，却又全躲藏着……\n而我，以及无数的我却在与它们悄悄竞争，我感到无助、无力，自叹不如！\n我用我易老的肉身与一双笨手，怎能与他们抗争！\n但我要以已之力，希望看到更多的异军突起，为了能有一个没有数据独裁（《生命3.0》《今日简史》）的未来，我愿意，我决心，奋力一搏！\n我愿意作那只螳臂当车的小小虫子！可笑？可怜？我怎么会介意。\n学习，不断学习，永远学习，我只能记得这些了，因为一只小虫子嘛。\n分享，详细分享，全面分享，我只能做出这些了，因为一只小虫子嘛。\n一条当然不怎么好走的路现在开始在脚底板下铺展，前景茫茫，我当然看不清楚。\n而你，朋友们，你愿意与我一起同行吗？\n如果你愿意，我将通过喜马拉雅听书网未来书屋频道分享每日学习笔记，通过各大技术论坛及平台分享详细笔记，通过视频网站平台与百度盘分享学习整个过程中的完整录像与个人感悟。以此分享，期待我的网络上的老师们给予指导。愿我们能一路相伴。\n为了和孩子一起玩，我们也在同时学习儿童机器编程和3D动画制作，每次玩耍后，我也会完全分享给大家的，欢迎大家共同参与。学习本身是有乐趣的，不是吗？"},
{"url": "https://www.douban.com/note/685161122/", "title": "Python爬虫小白入门（一）写在前面", "article": "https://www.cnblogs.com/Albert-Lee/p/6226699.html\nhttp://www.cnblogs.com/Albert-Lee/p/6230337.html\n一、前言\n你是不是在为想收集数据而不知道如何收集而着急？\n你是不是在为想学习爬虫而找不到一个专门为小白写的教程而烦恼？\nBingo! 你没有看错，这就是专门面向小白学习爬虫而写的！我会采用实例的方式，把每个部分都跟实际的例子结合起来帮助小伙伴儿们理解。最后再写几个实战的例子。\n我们使用Python来写爬虫，一方面因为Python是一个特别适合变成入门的语言，另一方面，Python也有很多爬虫相关的工具包，能够简单快速的开发出我们的小爬虫。\n本系列采用Python3.5版本，毕竟2.7会慢慢退出历史舞台~\n那么，接下来，你得知道什么是爬虫、爬虫从哪里爬取数据的，以及，学习爬虫都要学习哪些东西。\n二、什么是爬虫\n来看看百度百科是如何定义的\n网络爬虫\n（又被称为网页\n蜘蛛\n，网络机器人，在\nFOAF\n社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取\n万维网\n信息的程序或者脚本。另外一些不常使用的名字还有\n蚂蚁\n、自动索引、模拟程序或者\n蠕虫\n。\n什么？没看懂？没关系，我来给你解释一下\n打开一个网页，里面有网页内容吧，想象一下，有个工具，可以把网页上的内容获取下来，存到你想要的地方，这个工具就是我们今天的主角：爬虫。\n这样是不是更清晰了呢？\n既然了解了爬虫是什么，那么爬虫是如何爬取数据的呢？\n三、爬虫是哪里爬取数据的\n打开浏览器（强烈建议谷歌浏览器），找到浏览器地址栏，然后在里敲music.163.com，你会看到网页内容。\n欸，图片中间那俩人在干嘛？（单身狗请主动防御，这是误伤，这真的是误伤！）\n鼠标在页面上点击右键，然后点击view page source。看到这些文字了吗？这才是网页最赤果果的样子。\n其实所有的网页都是HTML代码，只不过浏览器将这些代码解析成了上面的网页，我们的小爬虫抓取的其实就是HTML代码中的文本啦。\n这不合理啊，难不成那些图片也是文本？\n恭喜你，答对了。回到浏览器中有图的哪个tab页，鼠标右键，点击Inspect。会弹出一个面板，点击板左上角的箭头，点击虐狗图片，你会看到下面有红圈圈的地方，是图片的网络地址。图片可以通过该地址保存到本地哦。\n你猜的没错，我们的小爬虫抓取的正是网页中的数据，你要知道你想要抓取什么数据，你的目标网站是什么，才可以把想法变成现实的哦。你不能说，我想要这个这个，还有这个，然后数据就自动来了。。。(是不是让你想起了你的导师或老板？)\n四、学习爬虫的必备知识\n大家要先对以下内容有一定的了解再来学习爬虫哦，磨刀不误砍柴工\nHTML\n这个能够帮助你了解网页的结构，内容等。可以参考\nW3School的教程\n。\nPython\n如果有编程基础的小伙伴儿，推荐看一个\n廖雪峰的Python教程\n就够了\n没有编程基础的小伙伴，推荐看看视频教程（网易云课堂搜Python），然后再结合廖雪峰的教程，双管齐下。\n其实知乎上总结的已经非常好了，我就不多唠叨了。\n知乎-如何系统的自学Python\nTCP/IP协议，HTTP协议\n这些知识能够让你了解在网络请求和网络传输上的基本原理，了解就行，能够帮助今后写爬虫的时候理解爬虫的逻辑。\n廖雪峰Python教程里也有简单介绍，可以参考：\nTCP/IP简介\n，\nHTTP协议\n\n想更深入学习的小伙伴儿可以去网上多搜搜相关的书籍哦\nOK, 下一篇就开始我们的实战"},
{"url": "https://www.douban.com/note/696237267/", "title": "孤荷凌寒自学python第三天 初识序列", "article": "孤荷凌寒自学python第三天 初识序列\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\nPython的序列非常让我着迷，之前学习的其它编程语言中没有非常特别关注过序列这种类型的对象，而python的序列被运用得特别频繁，且它的高效与简洁令我非常喜欢，于是学习的第二天就专门了解了序列的最基本的知识。\n首先目前我知道序列包括：字符串，列表，元组等这些对象。\n序列可以直接按元素在序列中的编号（index）来访问（index值从0开始计数）\n如：\n>>> strTemp='孤荷凌寒'\n>>> print(strTemp[0])\n孤\n>>> print(strTemp[-1])\n寒\n最让我激动的是，在python中将字符串直接作序列来看待，这和B系的程序语言是完全不同的，将字符串也看作序列的话，真是非常省心了。\n其次，了解了python中对序列非常方便快捷的“分片”，也叫切片操作，即可以直接取序列中指定的一部分出来 。\n格式为：\n取出的新序列对象 = 原长序列对象[起始index \n:\n 结束index[\n :\n 连续取元素的步长数值]]\n将取出的值是：\n起始index \n≤\n \n取出的元素片断index起止\n \n< \n结束 index\n其中“连续取元素的步长数值”是可选参数，默认值是：1\n如：\n>>> strTemp='我爱伟大的祖国。'\n>>> strT1=strTemp[0:3:1]\n>>> strT11=strTemp[0:3]\n>>> strT2=strTemp[-1:-4:-2]\n>>> print(strT1)\n我爱伟\n>>> print(strT11)\n我爱伟\n>>> print(strT2)\n。祖\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1AlEFYyPZ5KtAwjNOcuSbAw\n 密码：k4y6\nYouku\nhttps://v.youku.com/v_show/id_XMzkxMzMxMDUzNg\n \n喜马拉雅音频笔记整理\nhttps://www.ximalaya.com/keji/19103006/135434361\n \n   ����فe"},
{"url": "https://www.douban.com/note/738183393/", "title": "python--爬虫", "article": "下载地址：\n\n零基础：21天搞定Python分布爬虫\n链接：\nhttps://pan.baidu.com/s/1OJTJnOFGoooaExUmwFmo6Q\n提取码：4r2r\n千锋Python高级教程-Python爬虫从入门到高级实战（92集）\n链接：\nhttps://pan.baidu.com/s/1VktFJhGx_VlyT82TuoCTMA\n提取码：mgza\nScrapy爬虫框架视频\n链接：\nhttps://pan.baidu.com/s/1yzw05ho9IipjIt9aCgk3jw\n提取码：imyk\npython 35个项目实战\n链接：\nhttps://pan.baidu.com/s/1hHpnwbXIin4qZcMSa6r8Lg\n提取码：73h4\n爬虫介绍：\n1、什么是互联网？\n互联网是由网络设备（网线，路由器，交换机，防火墙等等）和一台台计算机连接而成，像一张网一样。\n2、互联网建立的目的？\n互联网的核心价值在于数据的共享/传递：数据是存放于一台台计算机上的，而将计算机互联到一起的目的就是为了能够方便彼此之间的数据共享/传递，否则你只能拿U盘去别人的计算机上拷贝数据了。\n3、什么是上网？爬虫要做的是什么？\n我们所谓的上网便是由用户端计算机发送请求给目标计算机，将目标计算机的数据下载到本地的过程。\n3.1 只不过，用户获取网络数据的方式是：\n浏览器提交请求->下载网页代码->解析/渲染成页面。\n3.2 而爬虫程序要做的就是：\n模拟浏览器发送请求->下载网页代码->只提取有用的数据->存放于数据库或文件中\n3.1与3.2的区别在于:\n我们的爬虫程序只提取网页代码中对我们有用的数据。\n4. 爬虫的价值：\n互联网中最有价值的便是数据，比如天猫商城的商品信息，链家网的租房信息，雪球网的证券投资信息等等，这些数据都代表了各个行业的真金白银，可以说，谁掌握了行业内的第一手数据，谁就成了整个行业的主宰，如果把整个互联网的数据比喻为一座宝藏，那我们的爬虫课程就是来教大家如何来高效地挖掘这些宝藏，掌握了爬虫技能，你就成了所有互联网信息公司幕后的老板，换言之，它们都在免费为你提供有价值的数据。\n公众号：吾爱软件001      ---python爬虫"},
{"url": "https://www.douban.com/note/692902827/", "title": "这破 Python", "article": "没想到我一个 07 年就入坑 \nCPyUG\n 从此走上从业道路的人，也会有来吐槽 Python 的一天。事实上自从上一次 Guido van Rossum 因为 \nPEP 572\n 事件而\n长文\n退出管理之后，我就想吐槽了。尤其是这个 Python 3.7 啊，你把 \nasync\n 改为保留字就算了，为啥作为属性还能报错，搞得基于 pylama 的静态检查在 3.7 下全部异常，真不知道管理层脑子里面都在想啥。\n工程选择上前有狼后有虎，排头的 JAVA / C / CPP 系只要自己不作，基本是干不赢的。要知道即便是人力成本贼高的「精通 C/CPP 」从业人员，就能产出的东西而言比招一个玩 Python 玩得 6 的高到不知道哪里去了，更何况 JAVA 狗遍地走，人力成本你拿头去比啊。后面 Go 这种比你复杂不了多少，一个静态强类型语言工程管理成本大幅降低，最不济的人家至少不会去争 tab 还是 space 对吧。重写就有性能数量级的提升，还容易部署，开发运维都开心。\n再看看 Python 这十几年都干了啥。10年前后 CPython 2 性能还能压着 Ruby 打，和 PHP 干得有来有回。现在一看 \nPerformance\n，连 Ruby 都能跳到 Python 头上踩一脚了，别提 \nPypy\n ，根本就上不了生产。11年的时候国内本来用 Python 的就少，我在金山做性能方面调研的时候算国内很早接触了 \nGevent\n/\nfapws3\n/\nuwsgi\n 的人，做了几次测试，写了几篇文章，翻译了几个报告，感觉这些东西真鸡儿棒，整个社区在这方面百花齐放，尤其是 Gevent。后来自己用 Gevent 实操了快盘的改造，又来到豆瓣以它为底层构建了 Douban App Engine，在 Python 2 的时代实现了全异步 IO 的应用框架，用过的开发都是爽得不要不要的。\n然后喵的又过了 6 年再看，都他妈 Python 3.7 了，大清都亡了百来年了，算上 \ntornado\n 这种显式 Promise/Future 的框架，能在生产中能弄起来的还是那么几样东西：Gevent，tornado，\ngreenify\n 和 flask/django 然后用 \ngunicorn\n 跑。\nAsyncio\n？是，标准库这个内置异步 IO 看起来香，吃起来是真的臭。好歹 Gevent 这类遇到 C level 的 IO 处理还有 greenify 这样的生产上验证过的库来 monkey patch 达到自动异步，各种生产的轮子也都有了，实在觉得隐式异步不好 debug 还有 tornado。一旦你用 Asyncio 就得自己重新实现一整套轮子。远的不说，MySQL 的 asyncio 异步轮子就没见着一个比 \nMySQLdb\n 完备度高的，看看 \naiomysql\n 的 \nissues\n，惨不忍睹，抄啥不好抄 \nPymsql\n。还有那对标 \nrequests\n 的 \naiohttp\n，都出来多久了，还能有\n这种\n坑，拿头跟 requests 比啊？\nSanic\n？抱歉，真的就只是一个 demo 而已，和 \nflask\n 就别比了。\n最后轰轰烈烈的 Python 2 和 Python 3 之争，字符串编码问题是解决了，结果引入了更多类型需要开发自行处理。王炸 Asyncio 发展了这么就还是个半成品全靠人填。yield 搞了半天语法糖还是不如隔壁 lua 的 coroutine，所以升个级最大的 feature 就是 print 成了函数么？\n这么久的 2 to 3，性能上被曾经脚下的 Ruby 骑在了头上，痛点 GIL 反正是不会碰的，一辈子也不会碰的，杀手级特性在工业上落地就要堆人，语言层面上也没见着一个更加简练高效的语法。GC 优化？不存在的，就当没这个 GC，然后 PEP 就过家家一样争要不要新的语法糖？\n喵喵喵？\n看看当年 PEP 333 意气风发，再看看如今 PEP 572 眼界狭隘，这 Python 啊吃枣药丸。"},
{"url": "https://www.douban.com/note/743521555/", "title": "风变编程——Python基础语法课体验", "article": "经历了三辆列车，20节课，终于从风变编程的基础语法课毕业了，分享下自己的上课感受吧。\n我最初对编程有好感是因为刘润老师建议说，如果生了娃一定要让他学两样东西，一个是编程，构建逻辑思维；一个是围棋，培养战略眼光。同时我觉得未来的几十年，学会编程、学会和电脑沟通就是一件像现在的我们会英语一样稀疏平常的事。\n我是正好还在备考司法考试的时候机缘巧合看到风变的体验课，两三节课上下来整体的交互式学习体验很棒，纠结了一下（毕竟有点贵）之后还是报名了基础语法和爬虫。\n（报了名之后才发现朋友圈里风变铺天盖地的广告，以及各路大V都在猛推，不由赞叹是个舍得花营销费的狠人）\n考完司法考试之后我就开始慢慢啃这块大骨头啦~\n一、课程环境\n整体上课环境就是如下图的界面，有课堂内置的练习，左边敲代码右边直接能看到运行结果。这点对于新手而言体验真的太好了，因为安装python、编译器的过程真的能劝退很多人。\n你按一下底下的回车就出来一句课程内容，给你一种（假装）在互动的感觉。\n我最喜欢的也觉得是风变课程价值最大的地方就是它的“列车”玩法。\n风变把基础语法课程量分成三辆列车：0-9关是从起点到山脚的车，10-14是从山脚到山腰，15-19关是从山腰到山顶。\n每乘上一辆列车（在微信里预约）就会被分到一个小群，群里有助教和同一进度的小伙伴。\n助教会带领大家一起学习，有任何学习上的问题都能找助教。其实在前几关的时候我都没怎么找过助教，因为题也不是很难，或者是虽然做不出，但看看答案也能看懂的那种。\n但到了冲顶列车的时候，由于涉及安装python、编译器，加上内容难度也上了一个台阶，我感觉我那几天已经把助教问得值回报名费了。而且你不按时学习的话，真的会收到助教的小锤锤。（截图是一个真的到！点！来！催！的良心助教）\n（从没想过大学毕业了还会被催着上课。。。。）\n当然还是想在此点名感谢下助教正义，因为我知道自己对电脑这方面的zz，很感谢他的耐心和指导。当然啦，群里也有很多热心（藏龙卧虎）的小伙伴，有些本身就是学c语言的，一些小问题他们就会帮你解决掉。\n整体氛围很好，大家群里讨论讨论问题，调戏调戏助教，快落地学习知识。\n二、我学到了啥\n说实话我觉得就算我现在基础语法毕业了，但学到的知识点是完全不扎实的，毕竟没有经历过大量反复的练习，你现在给我个任务甚至难一点的课堂原题我都只能干瞪眼。\n但我不后悔。因为对python有了个大概的了解，因为知道了以后遇到大量的重复性问题可以尝试用python解决，因为知道了以后对python知识点有疑问该去哪些网站寻找答案，因为发现这确实是一个值得学的课程，并且后续的课也愿意继续上下去。\n整体课程难度我觉得也有三个层次，体验课是在“哇，原来是这样，有意思”，“诶，挺简单啊”中度过；到了正式课程就明显上了一个台阶，每天学习要花的时间也不止半小时；最后就是山顶的几节课，完全就是题我看懂了，要求我也看懂了，但怎么做呢？啊，放弃吧，直接看答案好了。。。\n当然啦，教的都是很实用的知识点，就基础语法课的内容，能灵活运用的话也能解决很多问题了。总的来说还是要靠自己的，想要吸收、内化，少不了高中刷题那样的重复练习。\n（清醒一点，毕竟只学了三四十个小时就想着去抢程序员饭碗了吗？？）\n三、叨哔叨\n我报名之后在网上看到一篇阅读量很高的文章，吐槽风变的狂轰滥炸广告投放，但其实教的内容网上都有免费教程之类。我觉得他说的挺客观的，但我想了想，就算我在报名之前看到这文章，我觉得我还是会报名的，因为\n免费的东西不一定便宜\n：\n——你是想花钱买时间还是花时间省钱\n网上确实有好多免费python教程，一搜一大把。但通常而言，自学的话首先要安装python和编译器，对于连自己电脑是win10还是win7都分不清的我知道在安装这一环节我一定需要人帮助，如果纯靠自学的话，去哪里求助呢？论坛或者一些自发的学习群。提问了然后运气好有人回答，运气不好呢，自己再不断地去搜索找解决方案。这势必要投入大量的时间成本，但到最后问题也不一定能解决。\n但报名了基于契约关系，助教就有解答我问题协助我安装的义务，那我遇到问题了就不怕解决不了，至少能继续学下去。\n对于后续的学习也是同理，遇到不会的题，想不明白的点，可以自己尝试解决，如果解决不了，如果想直接知道答案，向助教求救就可以了，能节省很多时间。\n这让我想到当年备考注会的时候，我全程跟着东奥，最喜欢的也是它的答疑版功能，当你实在不会了，时间足够你就自己钻研钻研，时间紧迫那就直接丢到答疑版，让老师帮你解惑，高效、精准。\n所以权衡考虑课程价格和可能面临的困难可能花费的时间后，我还是选择了报名。\n另外有了助教的督促对于爱偷懒拖延症的学员也能起到个督促的作用。（我作为一个备考法考和注会的小勤奋，这点对我用处到不是很大，一般都是提前完成学习任务。。。）\n当然啦，以上都是基于我个人的体验。对于想尝试python的，还是挺推荐风变的，对于本来就有编程基础的伙伴或者自学能力超强的小伙伴完全可以尝试自学~\n稍事休息等12月向爬虫课发起进攻~~~"},
{"url": "https://www.douban.com/note/696317761/", "title": "孤荷凌寒自学python第四天 安装python的其它IDE环境", "article": "孤荷凌寒自学python第四天 安装python的其它IDE环境\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n因为是完全的新手，对python环境搭建完全一无所知，因此，可真是大费周章才配置了其它多个Ide编程环境。\n具体操作过程进行了全程屏幕录像，通过本文最后的链接，访问，也可联系我，获取4K高清的大文件录制视频 。\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1G02bsWUq8rT1yyaRSytuag\n  密码：u5yj\nYouku:\nhttp://v.youku.com/v_show/id_XMzkxMzMyODUwOA\n \nBilibili:\nhttps://www.bilibili.com/video/av35707376/\n \n喜马拉雅听书网语音笔记：\nhttps://www.ximalaya.com/keji/19103006/135884868"},
{"url": "https://www.douban.com/note/668202868/", "title": "数据科学家 (Data Scientist) 自我养成计划", "article": "微博\n：\n@领读PRO\ntwitter\n：\n@iDataScienceBro\n豆列\n：\nR & Python: from zero to hero\n \n算法：\n 零基础小白自学算法指南——入门（到放弃）\n这个帖子已经经过数次迭代，面貌和最初发表时可能已经有了很大的不同。今后也会随着我的学习进程不断修正。\n背景\n数据科学家 (Data Scientist) 据称是本世纪最为性感的工作。主要原因是随着互联网的兴起积累了海量的数据，人工智能也由此经历了量变到质变的突破。数据几乎每个公司和机构都有，而且越来越多的公司和组织开始意识到数据中潜藏的巨大财富和机遇。在这样的背景下，尽管有无数人中途转行从事了与数据相关的工作，众多高校和MOOC也针对这一现状开设了Data Science及相关领域的专业（或专项证据），相关的人才仍是供不应求。具有丰富经验和高超技能的成手数据科学家更是可以拿到非常丰厚的薪资。\n统计及编程软件背景\n 作为一个待毕业的半文科生，美国较为严峻的就业形势使我在一段时间的思考之后，打算转型做商业数据分析师或者数据科学家了。 我的数理统计知识不是很扎实，主要来自于为了统计的Minor所上的一些课程。不过我也算掌握了不少社会行为科学方面的比较高级的统计分析模型，比如结构方程模型，潜变量增长曲线模型，多水平分析模型，以及混合变量增长模型等。至于数据分析经验，过去几年我除了学术性的数据分析之外，还一直以研究助理的身份为州政府的Child Support机构做数据分析，有几个持续时间比较长的大项目，有几个也都用到了预测分析的模型，使用的分析软件则主要是SPSS和SAS。\n我此前的编程经验只限于一些统计软件，比如SPSS，Mplus，SAS等。R和STATA只懂一点。此外，准备SAS 证书的时候也学习了一些SQL的知识和比较初级的Macro编程。\nR or Python\nR 和Python是数据科学家最常用的两种编程语言。关于哪个最好最适合做数据挖掘和机器学习也有不少争论，以至于这个问题号称是价值百万的问题。从我目前看到的回应来说，如果你目前已经有很好的使用R进行数据分析，可视化，以及机器学习的基础，那么继续用R就是一个最佳选择。如果你没有用R或者Python进行编程的经验，或者你对于R只有非常初级和概略性的了解，那么Python一般被认为是更佳的选择。我个人非常喜欢Python这门语言，因为它非常的简洁，优雅，易学。而且，Python除了在数据科学中的应用，还可以用于编写一些小程序使得你的某些日常工作变得自动化。甚至你中途发现对数据分析没什么兴趣或天赋，也可以转行做网页开发什么的，Python仍可成为你得心应手的工具。\n计划\n虽然我去年就动了学习Python的心思，也搜集了一些学习材料，但当时只是粗粗翻了翻那些书，大致了解一下Python到底是什么。直到上个月底才开始真正学习Python。下面列出那两本书前面讲Python语法的部分我快速阅读学习了一遍，也适当的做了一下书中的练习。目前在跟着Udemy上的一套视频教程 \nComplete Python Bootcamp: Go from zero to hero in Python 3 \n继续加深对Python常用的语法结构的理解。语法入门之后，我要做的就是掌握用Python进行数据分析和绘图时最常用到的几个库，比如numpy，pandas，以及matplotlib，目标是熟练掌握基本而常用的语法进行数据的清理，制图，以及建模验证。关于机器学习的部分打算先过一遍书，然后跟着相应的视频教程走一遍，我当前的基础也无法对更底层的东西加以掌握。我是配合着刷Datacamp上的课程来加深对这些知识点的掌握的。\n入门（Python的基本语法知识）\n用到的书籍：\n\n《\nPython编程快速上手：让繁琐工作自动化\n》（很好）\n《\nPython编程：从入门到实践\n》（非常好）\n两本都是图灵社区出的，英文原版在美亚的口碑特高，适合零基础的人直接学起来，能试着实现一些自动化操作，都是基于Python 3。两本都很好，强烈推荐两本都看，互相补充，加深理解，但因为各种原因如果你只看一本，我推荐《从入门到实践》那本。\n\n视频教程：\n\n\nComplete Python Bootcamp: Go from zero to hero in Python 3\n 视频种子很容易搜到。这套视频我学下来觉得挺好，不是那种带你过家家当时觉得懂了些什么事后什么也做不了的课程。配合着作者精心准备的Jupyter notebook上的笔记和练习，可以对Python的语法和一般功能有着很好的掌握。\n用Python进行数据分析\n打算用到的两本书：\n\n1. \nPython for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython\n (作者 \nWes McKinney\n 也是Pandas这个著名Python数据分析库的作者，本书英文版去年刚出的第二版，第一版有中译本，名字叫《\n利用Python进行数据分析\n》，第二版有网友译本，译者是\n简书上的一个小哥\n，不过我大概看了一下，一些简单的文字部分都有不少错误，所以读起来要小心，最好等第二版的正式中译本出版，或者结合英文原版来学习。这类技术书籍中的英文一般都不是很难）\n2. 《\nPython数据科学手册\n》 这本书也是这两年刚出的一本书，英文版 \nPython Data Science Handbook: Essential Tools for Working with Data \n在美亚上的口碑也非常不错。我还没有细看，不过粗翻之下觉得体系和上面那本也比较相近，先介绍了IPython和Jupyter，然后着重介绍了用Python进行数据清理分析和数据可视化常用到的库。这本的好处是有中文版，学起来更快一些。\n视频\n打算快速学一下以下几套，都是Udemy上的\n\nData Analysis with Pandas and Python\n （我比较喜欢这个老师的课，不过他这个课不是项目导向的，用于演示的例子都比较简单，主要是用于介绍如何用Pandas这个包来进行data wrangling。）\n\nData Visualization with Python and Matplotlib\n (不是很喜欢这个老师的风格，觉得他说话的风格有些招人烦，所以目前没有深入地看这个视频教程）\n\nPython for Data Science and Machine Learning Bootcamp\n （这个老师和他的团队在Udemy上开了不少课了，都挺受欢迎的，我大致看了一下，觉得知识点覆盖的不是很细致，还是得结合着其他学习资源一同学习才行）\n机器学习\n这方面打算学习下面这本书，Udemy的视频，并打算修两到三个Coursera上的专项证书。\n书：\nIntroduction to Statistical Learning\n （机器学习/统计学习必读书目。作者中有两位也是The Elements of Statistical Learning (ESL)这本奠基性的著作的作者。相比ESL而言，本书面向的读者群较广，对于没有很高的数理基础的读者也非常友好。）\n\nHands-On Machine Learning with Scikit-Learn and TensorFlow\n （这本书也负有盛名，美国亚马逊上交口称赞，大多反映此书清楚易学。）\n\nUdemy\n \n视频：\n\n\nPython for Data Science and Machine Learning Bootcamp\n\n\nMachine Learning A-Z™ Hands-On Python & R In Data Science\nCoursera 课程\nMachine Learning from Stanford University (Andrew Ng)\n 必修课程。这门课有众多优点，名校，业内最顶级的学者讲授，对初学者友好，知识点的讲授非常的清晰，还能从中学到最佳的编码规范。因此也无怪乎这门课会收到无数赞誉。这门课当然也有小缺点，比如课程中用的Octave 和Matlab在现实工作中几乎没有人会用他们进行机器学习的实践，但是瑕不掩瑜，非常推荐从这门课开始入门。YouTube上斯坦福大学官方账号也上传了\n吴恩达在斯坦福校园授课时的全部录像\n。\n機器學習基石上 (Machine Learning Foundations)---Mathematical Foundations\n + \n機器學習基石下 (Machine Learning Foundations)---Algorithmic Foundations\n 这两门是台湾大学林轩田教授在Coursera上开设的，口碑非常不错，相比吴恩达大神的课，这门课对于数学（主要是微积分和线性代数）的要求就高多了。而且大家普遍表示这门课的作业难度不小（“难到想报警”），不过通过后收获会很大。\nMachine Learning with TensorFlow on Google Cloud Platform Specialization. \nTesorFlow 和Scikit-learn是用python做maching learning最著名的两个包。因此TensorFlow还是非常值得学习的。这里列出的这门课是Google Cloud官方推出的，一共五门课，全部修完可以拿到专项证书。\n练习\n我目前在datacamp上学习Data Scientist with Python这个career track的课程，一共20门课（最近又新增了两门，变成了22门），网站上给的估时是67小时（我实际学习下来，觉得完成的时间要比这个多出不少），不过如果基础还行也足够勤奋的话，还是有希望能够在一个月到一个半月内完成这个track的全部课程。\n从我目前学习的课程来看，大部分的课程的设置还是不错的，我最喜欢的是无数个穿插在课程中的小练习，可以有效地帮助我掌握新的知识点或者发现单独通过看视频很难察觉到的学习盲区。而且Datacamp还有APP可以下载，方便随时随地练习。\n不过，我不是很喜欢datacamp的视频课程，主要原因在于个别讲师说英语时口音有些重，而且还给人一种总踮起脚尖动来动去的感觉，萌是很萌，就是有些让人分心。不过每个课程都有配套的PDF讲义可以下载，所以我要么完全掠过课程（我已经从Udemy等处的相关课程中学到了相应的知识），要么1.5-2倍速快速地扫过。\n目前，Datacamp上Python Programmer这个Career Track的十门课我已经全部完成，Data Scientist with Python这个career track的课程我已经完成了63%。\n实战\nKaggle\n如同前面所说，我平时的RA工作其实就是在做数据分析，因此，有很多机会把学到的知识应用的平时的项目中。不过我也在考虑通过Kaggle参与一些与我现在的领域不同但是我很感兴趣的领域的项目。\nDatacamp Projects\nDatacamp上目前有15个Python projects， 我打算刷完Data Scientist with Python这个career track后抽空把这些projects实践一下。听一个在波士顿读书的小哥说，他就有同学通过datacamp上的这些项目的经验找到了BA的工作。\n他山之玉\n这个小标题下我会列出一些我看过并觉得有收获的帖子。\n一路披荆斩棘，我是如何成功拿到四大Data Scientist offer的?\n【求职转行】想往数据分析，偏statistic方向转行，有什么推荐的MOOC课程和平台呢？\n入門深度學習，讀對書很重要\nHow can I become a data scientist?\n （重点推荐一下 \nWilliam Chen\n 的回答，里面提到不少有用的资源。）"},
{"url": "https://www.douban.com/note/697121439/", "title": "孤荷凌寒自学python第十一天初识Python的字典类", "article": "孤荷凌寒自学python第十一天初识Python的字典类\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\nPython的字典其实是一张二维对照表\n下面举例说明：\n     \n键名Key\n姓名\n性别\n身高\n体重\n职业\n爱好\n……\n \n键值value\n张三\n男\n180\n74\n经理\n书法\n上图表的第一排，即是字典的KEY部分，KEY是寻找一个键值的关键索引名称，在同一个字典中，同个名称的key只能有一个。\nKey的的命名，只能是：数字、字符串、元组\nKey的名称一旦定义就不能更改。\n键值value是对应于key的一个内容，可以是任意python可接受的数据类型。\nValue可以在字典的操作过程中随时修改。\n现在将上表用python字典的声明方式来定义出来 。\n一、创建字典的三种方法：\n1 直接定义\n字典定义标识 符号是花括号{}\n例:\n>>> dictA={'姓名':'张三','性别':'男','身高':'180','体重':'74','职业':'经理','爱好':'书法'}\n \n>>> print(dictA)\n \n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n这是字典的默认存储格式，即key:value\n,\nkey:value……成对进行表示。\n2 将嵌套有多个元组的列表用以描述字典，然后使用全局函数 dict转换为字典\n在这种方法中，列表中的每个作为列表元素的元组中都有两个元素，一个是key,一个是value；然后将这些元组作为列表的元素嵌入列表。\n例：\n>>> lstA=[('姓名', '张三'), ('性别', '男'), ('身高', '180'), ('体重', '74'), ('职业', '经理'),( '爱好', '书法')]\n>>> dictA=dict(lstA)\n>>> print(dictA)\n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n3 直接将用等式连接的key=value这样格式组成的序列，使用dict函数转换成字典\n例：\n>>> dictA=dict(姓名= '张三', 性别= '男', 身高= '180', 体重= '74', 职业= '经理', 爱好= '书法')\n>>> print(dictA)\n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n特别注意的是，key=value格式中key部分是一定不使用引号标识的。\n二、修改字典的指定元素的value或向一个字典中新增元素\n这两种操作经过研究，发现语句写法是一模一样的\nDiction[keyname]=value\n其中Diction表示一个字典对象；\nkeyname表示key的命名；\nvalue表示key对应的值。\n新增与修改的不同在于：\n如果指定的keyname是当前字典Diction中已存在的元素的key，则是修改这个元素的value.\n如果 指定的keyname在当前字典Diction中没有对应的元素有这个key则新增一个以此keyname命名的key的新元素，其value为value.\n例：\n>>> print(dictA)\n{'姓名': '张三', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictA['姓名']='李四' #这次是修改，因为key‘姓名’已经存在了\n>>> print(dictA)\n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> dictA['年龄']=40  #这次是新增，因为key‘年龄’还不存在\n>>> print(dictA)\n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法', '年龄': 40}\n三、删除字典中的一个元素。\n只需要指明要删除的元素的key的命名，然后使用del函数即可：\ndel diction[keyname]\ndiction指的是字典对象。\nkeyname指要删除的字典元素的Key 名称。\n例：\n>>> print(dictA)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法', '年龄': 40}\n>>> del dictA['年龄']\n \n>>> print(dictA)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n四、删除字典对象本身\n这是说完全从内存中注销掉指定的字典对象。\ndel dictname\ndictname 指的是字典对象的变量名\n这样操作后，指定变量名对应的字典对象就不复存在了。\n五、格式化访问字典指定key名称的元素\n‘%（keyname）s’ %dictname\nkeyname指的是key的标识名称\ndictname是指字典对象\n例：\n>>> print(dictA)\n \n{'姓名': '李四', '性别': '男', '身高': '180', '体重': '74', '职业': '经理', '爱好': '书法'}\n>>> strTemp='%(身高)s' %dictA\n \n>>> print(strTemp)\n 180\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/17Q0Iys68rd_AuTVtJVEQIw\n  密码：1nxl\nBilibili:\nhttps://www.bilibili.com/video/av35777020/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/137665029"},
{"url": "https://www.douban.com/note/696429591/", "title": "孤荷凌寒自学python第五天初识python的列表", "article": "孤荷凌寒自学python第五天 列表\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n粗俗地区分列表，可以这样理解，定义或print列表后显示时，列表中的各元素都是用一个方括号[]括起来的。\n即列表看起来总是这样的：\nlstA=[1,3,5,7,9]\nlstB=[‘我’,’爱’,’祖’,’国’]\n同其它序列一样，要访问列表的元素，直接引用元素在序列中的index值即可\nlstA[0] 值是：1\nlstB[-1] 值是：‘国’\n一、将其它序列强制转换成列表\n新得到的列表对象 = \nlist(\n其它序列对象)\n如：\n>>> strTemp='孤荷凌寒'\n>>> lstTemp=list(strTemp)  #将字符串强制转换成列表\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒']\n二、其它序列如：元组、字符串等，都是不能直接改变序列中元素的内容的，包括修改元素值、增加新元素、删除元素、分片赋值等操作。\n而\n列表是允许进行内容修改的序列\n。\n三、列表元素的重新赋值\n如：\n>>> strTemp='孤荷凌寒'\n>>> lstTemp=list(strTemp)  #将字符串强制转换成列表\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒']\n>>> lstTemp[0]='大' #对列表的index值为0的元素重新赋值\n>>> print(lstTemp)\n['大', '荷', '凌', '寒']  #列表中指定元素的值被修改了\n四、向列表中添加元素\n使用append方法\n如：\n>>> strTemp='孤荷凌寒'\n>>> lstTemp=list(strTemp)  #将字符串强制转换成列表\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒']\n>>> lstTemp[0]='大' #对列表的index值为0的元素重新赋值\n>>> print(lstTemp)\n['大', '荷', '凌', '寒'] #列表中指定元素的值被修改了\n>>> lstTemp.append('帅') #向列表的最后添加一个元素’帅’\n>>> print(lstTemp)\n['大', '荷', '凌', '寒', '帅']\n五、删除元素\n使用全局del函数\n>>> del lstTemp[0]  #删除列表index值为0的元素\n>>> print(lstTemp)\n['荷', '凌', '寒', '帅']\n六、分片赋值\n分片赋值是指先取出列表中指定的切片段，然后直接通过=进行赋值，=的右边是值组成的列表，此列表的元素个数可以不与切片段中的元素个数相同。\n>>> print(lstTemp)\n['荷', '凌', '寒', '帅']\n>>> lstTemp[3:]=list('非常帅') # lstTemp[3:]这个分片（切片）中只有一个元素，值为‘帅’，=号右边却赋值了一个三个元素的列表。\n>>> print(lstTemp)\n['荷', '凌', '寒', '非', '常', '帅']\n七、向列表中指定位置插入元素\n操作与分片赋值一样，只是在分片（切片）时，指定的起始和结束index值是一样的，如：lstTemp(1:1) lstTemp(2:2)\n表示 在此index值的元素之前的位置插入若干个新元素。\n>>> print(lstTemp)\n['荷', '凌', '寒', '非', '常', '帅']\n>>> lstTemp[0:0]='孤' #插入元素’孤’到index值为0的元素之前的位置\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒', '非', '常', '帅']\n八、通过分片赋值方式删除一个区段切片中的多个元素\n这与第六点分片赋值完全一样，只是在赋值式的=号右边是一个空列表。\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒', '非', '常', '帅']\n>>> lstTemp[4:7]=[] #=右边赋值的是一个空列表，就等同于删除了切片部分的元素\n>>> print(lstTemp)\n['孤', '荷', '凌', '寒']\n九、书写序列的分片代码时，最容易犯的错误是，将分隔起止index值的符号 ： 写成 ， 号。\n这是从其它编程语言转变过来造成的不适应。\n如果分隔符号使用错误，会提示如下错误：\n>>> lstTemp[4,7]=[] #正确的写法是：lstTemp[4:7]=[]\nTraceback (most recent call last):\nFile \"<pyshell#19>\", line 1, in <module>\nlstTemp[4,7]=[]\nTypeError: list indices must be integers or slices, not tuple\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1ixQacJu3Bv1-7B9qWJOENA\n 密码：ypgv\nBilibili:\nhttps://www.bilibili.com/video/av35777463/\n喜马拉雅：\nhttps://www.ximalaya.com/keji/19103006/136107906"},
{"url": "https://www.douban.com/note/97716305/", "title": "BBC的Python电检", "article": "John Cleese：\n“大凡做公共电视广播的总会对节目内容留个心眼，这里说的是正派理由而非商业考量。我觉得BBC对我们的干涉绝对是最小量了，而且有几处我完全同意他们的看法。Eric写了一个有关方便的小品。我觉得完全没品，丢死人了。别人不这么想我没意见，但既然我觉得丢人，那我就认为BBC的干涉完全正派。他们还删掉了Terry Gilliam一幅动画——基督钉在了电话亭上。我不是说自己一定同意他们的作为——虽然在方便小品上的确认同——我的意思是那些掌管电视频道的人总得留个心眼在。”\n \nEric Idle：\n“John很不爽，但那小品讲的是势利眼，不是尿尿。”\n \n \nMichael Palin：\n“BBC终于注意到他们还有这么个节目。前两季BBC基本是三不管，到这会儿才发现素材有点过火了。我们有个叫‘Summarise Proust Competition’的小品，故事里参赛者得报出个人爱好，有一位的爱好是‘勒死动物，高尔夫，手拔（masturbating，你懂的）’。我们录完了小品，观众笑场强烈。BBC到这会儿才听了小品，要求把‘手拔’给删了。（导演）Ian被迫在开播前最后一刻给带子动了剪刀。所以（播放版本）有了块吓人的间隙，接着是‘高尔夫’，最后是一片轰笑。\n \n我们一起去BBC找了Duncan Wood，六个人坐那儿探讨了手拔之类的问题。记得Terry变得很激动，说，‘手拔到底无聊在哪里了？我手拔，你手拔，大家都手拔！’我心想，老天爷，会议快成飞机比赛了。 当然，在那个年代手拔还是个禁忌话题。没人会说起这个，人们做这事儿，就这么过日子，但从不讨论这个，更不会说上电视去。从第三季开始，像Bill Cotton这些此前从未现身的大人物，会突袭排练现场来监管我们。”\n \n \nTerry Gilliam：\n“有一回我觉得是John在演无间道。Ian MacNaughton当了替罪羊，但我相信是John使的坏。我们在拍拿宗教做乐子的小品，戏里某牧师在和人通电话，镜头跟着电线走，直到了地球另一端，那头手绑电话线的是上架耶稣。John对这桥段很不爽，为啥不爽就不晓得了。有那么几次都该是他在背后搞鬼。\n \n到了第三季，BBC开始感冒删东西了。事实证明脑子变态的是他们，不是我们。有场戏里John把条伤腿挤过门缝签收快递。我们和BBC一台总管Paul Fox碰了面，到他嘴里这场戏就变成有人把自个儿的大鸡巴挤过了门缝。天啊，那是条伤腿，在他们眼里却成了大鸡巴。\n我们就据理力争起来，最后弄得他很尴尬，因为我们是帮坏团伙。要我是总管，肯定也不愿见到这六人进来。实际上剧集在BBC二台重播时，他们对两个地方下了剪刀：一个是‘Summarise Proust Comepetition’小品，有个选手的爱好是高尔夫，勒死小动物和手拔，他们把手拔给哔掉了；另一处是我的动画，有位王子脸上生了个小点，他没当回事儿，结果很多年后小点变成了癌，王子就翘翘了——他们把癌改成了坏疽，因为癌成了个没法打笑的词。多美妙的时代啊，BBC二台重播节目的动画里连个癌字都不能说。”"},
{"url": "https://www.douban.com/note/635665023/", "title": "Python项目入门培训文档", "article": "Intro\n本篇文档是由近期给公司校招的新人（没有Python背景）准备的培训资料整理而来，学习计 划以学员的自学为主。根据实践平均每周学员需要花费1-2天的时间，每周再加上一个小时 跟踪和讲解相关内容。\n教程并不是单纯的Python语言培训，侧重点在于让新人快速参与项目开发。\nPython学习计划\n受众\n假定学员熟悉基本的编程概念，使用过Java/C/C++其中一门语言，有一定项目开发经验\n目标\n预计为期8周的阅读及学习计划，以完成每周设定的任务的方式引导学习Python语言以及 相关开发知识，帮助学员进行Python项目开发\n需要完成的任务包括：\n完成参考资料的阅读（扩展阅读不作要求）\n完成一些具体的编程练习\n阅读一些库的文档并编写例子初步掌握使用\n进度反馈及跟踪\n每周会有例会跟踪进度，平时的反馈通过邮件进行\n第1周 Intro\n本周目标\n在开始学习Python语言的具体知识细节前了解一些背景知识，以及设置一个Python开发环境\n请完成以下材料的阅读\n背景知识了解\n简单的Python历史介绍\n人生苦短，我用Python\nPython语言的设计哲学\nThe Zen of Python\n中文翻译参考\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than right now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\nPython社区\n社区\nPEP，中文翻译为Python增强提议。这个词经常在Python学习过程中看到，了解什么是PEP\nPSF，Python Software Foundation, Python软件基金会\nPyCon, 每年社区举办的Python开发者大会，youtube上可以找到与会演讲视频\n了解Python2和Python3的现状\nShould I use Python 2 or Python 3 for my development activity?\nPython2版本将于2020年正式停止更新维护，Python语言的未来以及最新改进在Python3版本上进行\n新项目应该默认使用Python3进行开发\n现存的大量项目以及第三库使用Python2版本，流行的Python库大多兼容Python2/3版本\n目前公司的项目使用Python2版本\n编程环境设置\n选择Python解释器\nPicking an Interpreter\n安装Python\nProperly Installing Python\n了解pip\nPython的包管理工具，类比Java语言的Maven工具\npip包管理器使用详解\n文档\nIDE & Editor\n项目组使用PyCharm进行Python开发，请下载安装并熟悉使用\n介绍\n官网\n前端项目使用VS Code作为开发环境\nWhy Visual Studio Code? - 为什么选用VSCode\n官网\n编程练习\n在本地安装设置好Python2.7开发环境\n使用pip安装requests库，\n参考资料\n安装并设置好PyCharm\n使用PyCharm建立项目，编写程序使用requests使用GET请求访问 \nhttp://www.bing.com\n 并输出内容，\n参考资料\n扩展阅读\nPython流行的第三方库支持Python3的情况\n前端项目使用\nJavaScript Standard Style\n 作为代码风格标准\npythonclock\n第2周 开始Python学习\n本周目标\n本周将进行为期三周的Python语言学习，每周将指定的一些练习题目，请尝试完成（来源于Python Koan项目）。\n阅读材料中将列出一些参考的Python学习教程，学员会有比较充足的时间进行自由的学习。\nPython Koan项目\nPython Koan是通过TDD进行Python学习的一个项目，\n项目地址\n 请下载并按照文档设置，注意我们使用python2文件夹下的代码\n每个题目都关于Python语言的一个特性，完成题目可以帮助掌握这个特性。 如遇到题目涉及到的教程中没有提及的概念，可以跳过。 \nPython Koan 答案参考\n （注意此答案使用Python3版本）\n阅读材料\n快速入门\n写给有经验程序员的Python入门教程\n 快速了解Python特性\nPython 核心特性\n Section 1-11\n请完成以下教程\nWelcome to Python for you and me\n （比较简洁，PEP8 Guidelines，Virtualenv及之后章节可跳过)\n编程练习 | 本周的Python Koan题目\nabout_asserts.py\nabout_strings.py\nabout_none.py\nabout_lists.py\nabout_list_assignments.py\nabout_dictionaries.py\nabout_string_manipulation.py\nabout_tuples.py\nabout_methods.py\nabout_control_statements.py\nabout_true_and_false.py\nabout_sets.py\n第3周 继续Python Koan题目\n本周目标\n阅读材料\n请完成以下教程\nPython官方入门教程\n (阅读2-9章节即可)\n编程练习 | 本周的Python Koan题目\nabout_triangle_project.py\nabout_exceptions.py\nabout_triangle_project2.py\nabout_iteration.py\nabout_comprehension.py\nabout_generators.py\nabout_lambdas.py\nabout_scoring_project.py\nabout_classes.py\nabout_new_style_classes.py\nabout_with_statements.py\nabout_monkey_patching.py\nabout_dice_project.py\nabout_method_bindings.py\n第4周 decorator and context manager\n本周目标\n相信大家对编程语言中的基于数据和基于函数的抽象都不陌生，现在来看一下Python对于基于语法的抽象的支持。\n了解Python中装饰器(decorator)的概念\n了解Python中上下文管理器(context manager)的概念\n阅读材料\n装饰器\n 简短介绍\nA guide to Python’s function decorators\n上下文管理器\n 简短介绍\nPython in the real world: Context Managers\n编程练习 | 本周的Python Koan题目\nabout_decorating_with_functions.py\nabout_decorating_with_classes.py\nabout_inheritance.py\nabout_multiple_inheritance.py\nabout_scope.py\nabout_modules.py\nabout_packages.py\nabout_class_attributes.py\nabout_attribute_access.py\nabout_deleting_objects.py\nabout_proxy_object_project.py\nabout_proxy_object_project.py\nabout_extra_credit.py\nabout_regex.py\n扩展阅读\n标准库中的context manager工具\n参考书目\n学习了两个教程之后对Python语言已经有大致的了解，接下来如果需要深入学习，建议找一些严肃的书籍进行系统性的学习。\npython books\n学习Python\n资源\nBest Python Resources\n Full Stack Python 本身也是很好的学习资源\n第5周 编程风格与命令行开发\n本周目标\n了解Python编程风格及命令行开发工具.\nPython code style 业界现在有两个标准，PEP8 以及 \nGoogle Python Style Guide\n 项目组采用PEP8标准，对于Google Style可以稍作了解\n除了日常在IDE里进行Python开发，开发人员也应该掌握一些在命令行环境下进行编程和debug的技能\n阅读材料\n代码风格\n \n英文版\n虚拟环境\n virtualenv\nPip和Virtualenv的更多配置\nPEP8\n 建议阅读这个美化过的排版，\n原版\n地址\nyapf\n Google 出品的自动化格式代码工具，建议了解一下\nipython\n官网\n作为一个交互式shell, 用来代替默认的python命令行编程环境# 使用以下命令安装python2.7版本的ipython pip install 'ipython<=6.0.0' \npdb\nPython debuger, 交互式debug环境。类似于GDB\n使用教程\nvim\n命令行环境下的编辑器\n交互式的VIM简短教程\n 十分炫酷的简短教程，掌握日常用到的最基本操作\n编程练习\n本周没有具体的编程练习，请花一点时间熟悉一下pip/virtualenv/ipython/pdb/vim工具。\n编辑器/IDE是非常重要的工具，在工作过程中几乎所有的开发时间都花这上面，所以不 论你喜欢vim/emacs/vs code/atom/sublime text，你应该熟悉你的编程器/IDE。花些时间去了解 你喜欢的编程器/IDE\n适当设置好开发环境对于提高开发效率也相当重要，有兴趣可以了解一下扩展阅读里列出的工具\n扩展阅读\n你的开发环境\n \n英文版\nMac 开发配置手册\nwindows开发环境\n个人推荐 Cygwin + ConEmu + zsh + oh-my-shell + CoreUtils\nCygwin\nConEmu\n终极Shell\n 在Cygwin环境中也可以使用zsh + oh-my-zsh\nCoreUtils for Windows\n 常用的liunx命令windows移植\n配置豪华的 Windows 开发环境\n第6周 标准库及其它\n本周目标\n大概了解下Python标准库, 一些第三库/框架\n阅读材料\n标准库\nPython标准库——走马观花\nPython标准库01 正则表达式 (re包)\nPython标准库03 路径与文件 (os.path包, glob包)\nPython标准库04 文件管理 (部分os包，shutil包)\nPython标准库06 子进程 (subprocess包)\nPython标准库08 多线程与同步 (threading包)\n常用库\nOslo\nOslo 是由openstack项目衍生出来的一系列python库，为openstack众多项目提供统一的公共功能。\nTo produce a set of python libraries containing code shared by OpenStack projects. The APIs provided by these libraries should be high quality, stable, consistent, documented and generally applicable\n官方Wiki Oslo库列表\n阅读使用和配置文档，大概了解这些包是用做什么的即可。\noslo.cache\noslo.concurrency\noslo.config\noslo.log\noslo.policy\npbr\nSQLAlchemy\nSQLAlchemy 是一个连接数据库的ORM框架 大概了解 SQLAlchemy 的简单使用方式，不要求深入了解\n官网\n简单介绍\n简单使用教程\n第7周 开源工具\n本周目标\n了解一些开源工具及项目开发协作相关工具\n由于列出的工具较多，不要求深入了解\n阅读材料\nMarkdown\nMarkdown语法\n 平时写文档时可以使用Markdown语法\n示例网站 \nhttps://maxiang.io/\n 可以看到左边为文本内容，右边为渲染后的效果。使用markdown语法，书写文档时不需 要关心排版效果，可以专注于内容本身。\nGit && Gerrit\n项目组使用Git进行代码版本管理，使用Git是一项必备技能。如果以前没有使用Git的 经验，请务必花一些时间学习。\n版本控制Git和代码审阅Gerrit\nGit教程\nGerrit Code Review - A Quick Introduction\nJenkins && CI\nJenkins与持续集成(CI)介绍\ntox\nPython 的单元测试之 tox\ntox官网介绍\n运维利器 Ansible\n自动化运维工具，可以稍作了解，日常工作中可能会用到ansible工具来批量运行脚本\nAnsible 简介\n 阅读简介至ad-hoc部分即可\nAnsible中文权威指南\n 如果有兴趣深入了解\n第8周 实战\n本周目标\n本周为编程练习，创建一个Python项目，并编程完成要求\n这个项目是完成一个命令行工具，可以通过命令行调用来完成数据库表的CUDR操作\n编程练习\n配置pip文件\n安装并配置PostgreSQL数据库\ntips: 可以使用 NaviCat pgAdmin 等数据库管理工具\n配置数据库密码为 test123456\n创建database, 名称: cudr\n在 cudr 新建表，表名example\n创建 sql 如下\nDROP TABLE IF EXISTS \"public\".\"example\";\nCREATE TABLE \"public\".\"example\" (\n\"name\" varchar(127) COLLATE \"default\" NOT NULL,\n\"code\" varchar(63) COLLATE \"default\" NOT NULL\n)\nWITH (OIDS=FALSE)\n;\nALTER TABLE \"public\".\"example\" ADD PRIMARY KEY (\"name\");\n创建一个Python项目\n项目名称 cudr\n项目结构请阅读\n结构化你的工程\n 中仓库的结构一节，关于 Django Applications及之后的章节可跳过\n在 requirements.txt 文件中指定项目依赖库\nsqlalchemy\nclick\n\n使用pip安装依赖\npip install -r requirements.txt\nclick 用于创建命令行工具\n官网\n简单使用教程\nsqlalchemy 数据库ORM工具\n编程\n在 cudr/core.py 中完成具体的代码工作\n具体代码实现以及命令行使用参数的设计可以自由发挥\n最终效果要求可以完成类似以下功能(不要求和下面示例代码中一样)\n创建\n读取\n修改\n删除\n# 创建一个数据库记录\npython core.py --create name1 code1\n# 读取\npython core.py --read name1\n# 修改 指定主键name1及更新的字段及字段的新值\npython core.py --update name1 name=name2\n# 删除\npython core.py --delete name2"},
{"url": "https://www.douban.com/note/698628252/", "title": "孤荷凌寒自学python第二十四天python类中隐藏的私有方法探秘", "article": "孤荷凌寒自学python第二十四天python类中隐藏的私有方法探秘\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n今天发现了python的类中隐藏着一些特殊的私有方法。\n这些私有方法不管我们定义类时是否在类的内部代码块中定义过它们，这些私有方法都是存在的。比如已经知道的 __init__ 方法就是其中一个。\n一、__str__\n此方法将输出在本身的相关信息文本。\n测试：\nclass ghlh(object):\nname='孤荷凌寒'\nqq='578652607'\nnewghlh=ghlh()\nstrTemp=newghlh.__str__()\nprint(strTemp)\n运行结果 ：\n<__main__.ghlh object at 0x000002030E274CC0>\n当然同 __init__ 方法一样，我们可以自己重新覆盖 书写 此方法的代码：\nclass ghlh(object):\nname='孤荷凌寒'\nqq='578652607'\ndef __str__(self):\nreturn self.name\nnewghlh=ghlh()\nstrTemp=newghlh.__str__()\nprint(strTemp)\n现在的运行结果：\n孤荷凌寒\n二、__iter__\n通过类的此方法，可以使一个类的实例化对象变成一个迭代器。\n但是此方法必须配合显式定义过的：\n__next__\n方法同时使用才有实际功用。\n测试如下：\nclass ghlh(object):\nname='孤荷凌寒'\nqq='578652607'\na=0\nb=1\ndef __str__(self):\nreturn self.name\ndef __init__(self,a=0,b=1):\nself.a=a\nself.b=b\ndef __iter__(self):\nreturn self #通过此语句，使类的实例化对象成为一个迭代器，可以在被 循环语句 读取时，每次返回自身中 __next__ 方法的下一对象值\ndef __next__(self):\nself.a,self.b=self.b,self.a+self.b #每次被访问本迭代器时，都返回当前a,b的下一个值，b=上一个a+上一个b\nif self.a>10000: #加个条件，使本 迭代器 成为一个有限元素的 迭代器，否则将无穷下去。\nraise StopIteration #当达到条件时，通过raise返回一个迭代元素结束的错误来使本 迭代器 的元素是有限的。\nreturn self.a #每次被 访问 本迭代器时，将a的值返回给调用的 循环语句\nnewghlh=ghlh()\n#strTemp=newghlh.__str__()\n#print(strTemp)\n#因为我们已经在类中定义了 __iter__ 方法 和 __next__ 方法，现在类的实例化对象 newghlh 已经成为了一个迭代器，可以在循环体中直接使用了。\nfor n in newghlh:\nprint(n)\n运行结果 ：\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n三、 __getitem__\n通过显式地编写好此私有方法的代码，可以实现将类实例化后的对象当作列表来使用的效果。\n测试：\nclass ghlh(object):\nname='孤荷凌寒'\nqq='578652607'\na=0\nb=1\ndef __str__(self):\nreturn self.name\ndef __init__(self,a=0,b=1):\nself.a=a\nself.b=b\ndef __iter__(self):\nreturn self #通过此语句，使类的实例化对象成为一个迭代器，可以在被 循环语句 读取时，每次返回自身中 __next__ 方法的下对象值\ndef __next__(self):\nself.a,self.b=self.b,self.a+self.b #每次被访问本迭代器时，都返回当前a,b的下一个值，b=上一个a+上一个b\nif self.a>10000: #加个条件，使本 迭代器 成为一个有限元素的 迭代器，否则将无穷下去。\nraise StopIteration #当达到条件时，通过raise返回一个迭代元素结束的错误来使本 迭代器 的元素是有限的。\nreturn self.a #每次被 访问 本迭代器时，将a的值返回给调用的 循环语句\ndef __getitem__(self,n):\nfor x in range(n): #将a的值变化 n 次（最大次数），然后就相当于建立 了一个 内部元素 总数为 n 个的列表\nself.a,self.b=self.b,self.a+self.b\nreturn self.a\nnewghlh=ghlh()\n#strTemp=newghlh.__str__()\n#print(strTemp)\n#因为我们已经在类中定义了 __iter__ 方法 和 __next__ 方法，现在类的实例化对象 newghlh 已经成为了一个迭代器，可以在循环体中直接使用了。\n#for n in newghlh:\n# print(n)\nintNew=newghlh[3] #现在对于 ghlh 类实例化的 对象 newghlh 可以像使用 列表一样访问其元素了。\nprint(intNew)\n运行结果 ：\n2\n四、__getattr__\n通过此内部方法来获取类实例化后的对象中的对象时，就算要获取 的对象根本不存在，也不会抛出错误。\n五、__call__\n通过显式地编写此私有方法的代码，主要是给此方法函数添加形式参数（也可以不添加形式参数），并让函数内部代码块执行一定的操作。\n那么只要在类的内部代码块中显式地重定义了此方法函数，就可以将 此 类 实例化后的对象名 当作一个函数名称来使用，当调用这个“函数”时，实则上是执行了类代码中的私有方法：\n__call__\n测试：\nclass ghlh(object):\nname='孤荷凌寒'\nqq='578652607'\na=0\nb=1\ndef __str__(self):\nreturn self.name\ndef __init__(self,a=0,b=1):\nself.a=a\nself.b=b\ndef __iter__(self):\nreturn self #通过此语句，使类的实例化对象成为一个迭代器，可以在被 循环语句 读取时，每次返回自身中 __next__ 方法的下对象值\ndef __next__(self):\nself.a,self.b=self.b,self.a+self.b #每次被访问本迭代器时，都返回当前a,b的下一个值，b=上一个a+上一个b\nif self.a>10000: #加个条件，使本 迭代器 成为一个有限元素的 迭代器，否则将无穷下去。\nraise StopIteration #当达到条件时，通过raise返回一个迭代元素结束的错误来使本 迭代器 的元素是有限的。\nreturn self.a #每次被 访问 本迭代器时，将a的值返回给调用的 循环语句\ndef __getitem__(self,n):\nfor x in range(n): #将a的值变化 n 次（最大次数），然后就相当于建立 了一个 内部元素 总数为 n 个的列表\nself.a,self.b=self.b,self.a+self.b\nreturn self.a\ndef __call__(self,strMsg):\nprint('这是在类内部代码块中声明的一个方法：收到的形式参数对应的实参的值是：“' + strMsg + '”')\nnewghlh=ghlh()\n#strTemp=newghlh.__str__()\n#print(strTemp)\n#因为我们已经在类中定义了 __iter__ 方法 和 __next__ 方法，现在类的实例化对象 newghlh 已经成为了一个迭代器，可以在循环体中直接使用了。\n#for n in newghlh:\n# print(n)\n#intNew=newghlh[3] #现在对于 ghlh 类实例化的 对象 newghlh 可以像使用 列表一样访问其元素了。\n#print(intNew)\nnewghlh('将类的实例化后的对象当作了函数来使用，这是传递的实际参数') #现在可以像调用函数一样调用这个类的实例化对象名称\n运行结果：\n这是在类内部代码块中声明的一个方法：收到的形式参数对应的实参的值是：“将类的实例化后的对象当作了函数来使用，这是传递的实际参数”\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1p_0uK4C8MBN-p6vtIBXPUQ\n  密码：p1z1\nBilibili:\nhttps://www.bilibili.com/video/av36211518/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/140981786\n \n   �R�7"},
{"url": "https://www.douban.com/note/698411101/", "title": "孤荷凌寒自学python第二十二天python类的继承", "article": "孤荷凌寒自学python第二十二天python类的继承\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\npython中定义的类可以继承自其它类，所谓继承的概念，我的理解 是，就是一个类B继承自类A,意味着类B的内部代码块中就算不写任何代码，类B仍然拥有类A的所有公开的属性和方法。\n这个优势非常方便于我们在要创建一个在原有类的基础上只是稍微有所变化 的类时，可以只通过继承一个类之后，再作属性和方法增改即可完成，大大的减轻了代码工作量。\n在类的继承活动中，被继承的类称之为【基类】也叫【父类】\n而继承【基类】而得到的新的类，叫【子类】\n一、单一继承\n一个【子类】只从一个【基类】继承而来。\n测试：\nclass cup(object): #作为基类\n__private='我是cup类的私有属性'\npublic='我是cup类的公开属性'\none='我是cup类的第一属性'\n__two='我是cup类的第二属性'\ndef __init__(self,one,two):\nself.one=one\nself.two=two\ndef publicmethod(self,var1,var2):\nreturn \"cup类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self):\nprint('这是cup类中的私有方法打印的内容。')\nnewcupone=cup('陶瓷','白色')\nstr1=newcupone.publicmethod('内容一','内容二')\nclass bluecup(cup): #继承自cup类的子类\npass #当前 子类 内部代码 什么也没有定义。\nnewbluecupone=bluecup('玻璃','蓝色')\nstr2=newbluecupone.publicmethod('子类的内容一','子类的内容二')\nprint(str1)\nprint(str2)\n运行结果：\ncup类的公开方法收到的参数是：内容一,内容二,私用属性__two=我是cup类的第二属性\ncup类的公开方法收到的参数是：子类的内容一,子类的内容二,私用属性__two=我是cup类的第二属性\n从运行结果中注意到，基类cup的实例化对象newcupone执行方法：publicmethod\n和\n子类bluecup的实例化对象newbluecupone执行方法：publicmethod\n得到的结果实质上并没有什么不同。\n这是因为子类bluecup没有定义自己的publicmethod方法，因此 只是完全照搬cup类的这个方法而已。\n子类并没有继承基类的私有方法与属性。\n测试如下：\nclass cup(object): #作为基类\n__private='我是cup类的私有属性'\npublic='我是cup类的公开属性'\none='我是cup类的第一属性'\n__two='我是cup类的第二属性'\ndef __init__(self,one,two):\nself.one=one\nself.two=two\ndef publicmethod(self,var1,var2):\nreturn \"cup类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self):\nreturn '这是cup类中的私有方法打印的内容。'\nnewcupone=cup('陶瓷','白色')\nstr1=newcupone.publicmethod('内容一','内容二')\nclass bluecup(cup): #继承自cup类的子类\nbluecupnewshuxing=cup.__privatemethod() #这儿尝试调用基类的私用方法__privatemethod，注意调用方法是：基类名.基类方法()\n#执行上一语句会出错。因为子类并没有继承基类的私有方法\nnewbluecupone=bluecup('玻璃','蓝色')\nstr2=newbluecupone.publicmethod('子类的内容一','子类的内容二')\nprint(str1)\nprint(str2)\n运行结果：\nTraceback (most recent call last):\nFile \"c:\\Users\\pw\\Desktop\\新建文本文档.py\", line 19, in <module>\nclass bluecup(cup): #继承自cup类的子类\nFile \"c:\\Users\\pw\\Desktop\\新建文本文档.py\", line 20, in bluecup\nbluecupnewshuxing=cup.__privatemethod() #这儿尝试调用基类的私用方法__privatemethod，注意调用方法是：基类名.基类方法()\nAttributeError: type object 'cup' has no attribute '_bluecup__privatemethod'\n当然子类中可以调用基类的公用方法，调用方法仍然是;\n基类名.基类方法()\n二、多重继承\n一个类也可以从多个基类中继承属性和方法，称之为多重继承，只需要在定义类的基类列表中输入多个基类名称即可。\nclass cup(object): #作为基类\n__private='我是cup类的私有属性'\npublic='我是cup类的公开属性'\none='我是cup类的第一属性'\n__two='我是cup类的第二属性'\ndef __init__(self,one,two):\nself.one=one\nself.two=two\ndef publicmethod(self,var1,var2):\nreturn \"cup类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self):\nreturn '这是cup类中的私有方法打印的内容。'\ndef 倒掉水(self):\nreturn '这是cup类执行了【倒掉水】的方法。'\nclass glass(object): #作为基类\n__private='我是glass类的私有属性'\npublic='我是glass类的公开属性'\none='我是glass类的第一属性'\n__two='我是glass类的第二属性'\nthree='我是glass类的第三属性'\ndef __init__(self,one,two,three):\nself.one=one\nself.two=two\nself.three=three\ndef publicmethod(self,var1,var2):\nreturn \"glass类的公开方法收到的参数是：\" + var1 + \",\" + var2 + ',私用属性__two=' + self.__two\ndef __privatemethod(self):\nreturn '这是glass类中的私有方法打印的内容。'\ndef 碎掉(self):\nreturn('glass类的实体化对象执行此方法后，碎掉了。')\nclass cupglass(cup,glass): #继承自cup类和glass类而实现双重继承的子类\npass\nnewobj=cupglass('玻璃','蓝色') #因为定义cupglass类时，基类列表是有顺序的，基类cup在列表最前面，优先级最高，因此以它的初始化方法函数 的参数个数为准\nnewobj2=cupglass('陶瓷','白色')\nstr1=newobj.publicmethod('子类的内容一','子类的内容二')\nstr2=newobj2.publicmethod('子类二的内容一','子类二的内容二')\nprint(str1)\nprint(str2)\n运行结果：\ncup类的公开方法收到的参数是：子类的内容一,子类的内容二,私用属性__two=我是cup类的第二属性\ncup类的公开方法收到的参数是：子类二的内容一,子类二的内容二,私用属性__two=我是cup类的第二属性\n从运行结果从可以看出，cupglass类继承两个基类中同名的公开方法publicmethod时，发现永远都只执行了cup基类的publicmethod方法，这是为什么呢？\n原来定义cupglass类时，基类列表是有顺序的，基类cup在列表最前面，优先级最高，所以当多个基类中出现重名的对象时，默认继承优先级高的基类的对象。\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/17kG7YiFYV20s7j6ML88mZw\n  密码：mpag\nBilibili:\nhttps://www.bilibili.com/video/av36211003/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/140522246"},
{"url": "https://www.douban.com/note/697712194/", "title": "孤荷凌寒自学python第十六天python的迭代对象", "article": "孤荷凌寒自学python第十六天python的迭代对象\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\n迭代也就是循环。\npython中的迭代对象有相关的如下几个术语：\nA容器 contrainer\n序列/集合/字典等都是容器，我的理解是因为它们都容纳了很多的元素在其中，每个元素都是别的对象，所以称他们为容器非常贴切。\nB 可迭代对象 iterable\n大部分容器都是可迭代对象（iterable）\n可迭代对象的意思 是，这个对象本身可以提供有限数量的内部元素供循环语句遍历，因此多数容器都符合这个条件。\nC 迭代器 iterater\n可迭代对象可以转换为 迭代器\n使用函数\n迭代器对象=iter(可迭代对象)\n就可将一个可迭代对象转换为一个 迭代器。\n 迭代器 可以直接自动地 逐一将自己变量名所指向 的 内存中的地址 中的元素 一个一个地 根据循环语句的 需要 逐次（每次提交下一个元素 指向内存的起始地址给循环体）\n提供。\n部分迭代器 甚至可以将有限的元素集合模拟成无限的数量。循环语句获取时将发现似乎其中的元素永远都取之不尽。这个目前我没有深入研究。\n用print语句尝试输出迭代器对象时，会发现，打印出的它被表示成了内存地址的形式。\nD 生成器——一种特殊的迭代器\ngenerator\nyield\n关于生成器，目前没有深入学习。\n一、判断 一个 对象 是不是 可迭代对象，是不是 迭代器 的方法\n需要引用模块（库），然后再使用相关函数 \n用到的库是：\ncollections.py\n引用声明：\nfrom collections import Iterable\nfrom collections import Iterator\n然后使用全局函数\nisinstance来判断类型\n1 判断 一个对象 是否是一个可迭代对象\nisinstance(要判断的对象,Iterable)\n函数返回布尔值。\n2 判断 一个对象 是否是一个迭代器\nisinstance(要判断的对象,Iterator)\n函数返回布尔值。\n二、其它可以自动产生迭代器的常用函数\niter函数可以将 可迭代对象转换成 迭代器\n除此之外，以下函数 也可以生成 迭代器：\n1 range()函数\nrange函数用于生成指定的整数序列列表对应的迭代器\n格式：\n新的迭代器对象=range(起始整数(包含此数),结束整数(不包含此数),步长)\n测试：\n>>> itrA=range(1,20,2)\n>>> print(itrA)\nrange(1, 20, 2)\n>>> for a in itrA: #itrA作为一个迭代器，可以向循环语句中的变量a逐一提供其中的元素。\nprint(a)\n1\n3\n5\n7\n9\n11\n13\n15\n17\n19\n2 enumerate()函数\n此函数会将一个普通序列转换成由元素本身在序列中的index数值与元素对象本身一一对应的一个个元组对组成的复合序列对象对应的 迭代器\n格式：\n新的迭代器=enumerate(序列对象)\n测试：\n>>> lstA=list('大家好，我是孤荷凌寒')\n>>> itrB=enumerate(lstA)\n>>> print(itrB)\n#用print语句输出迭代器时，会发现打印出的它被表示成了内存地址的形式。\n<enumerate object at 0x000001C940156EA0>\n>>> for index,obj in itrB: #迭代器itrB每次向循环语句提供同一元素的两个对象\nprint('当前元素index:',index,'值：',obj)\n当前元素index: 0 值： 大\n当前元素index: 1 值： 家\n当前元素index: 2 值： 好\n当前元素index: 3 值： ，\n当前元素index: 4 值： 我\n当前元素index: 5 值： 是\n当前元素index: 6 值： 孤\n当前元素index: 7 值： 荷\n当前元素index: 8 值： 凌\n当前元素index: 9 值： 寒\n3 sorted()函数\n对序列进行排序。\n格式：\nsorted(序列对象,key=排序关键字函数,排序方向的布尔值)\n排序关键字函数，是我的理解并备注。\n此参数是关键字参数，必须以\nkey=函数名\n或\nkey=适时定义的匿名函数\n的方式来进行传递。\n而我的理解是，这个函数其实只是指定了以序列中的元素的哪个关键字（或部分）来进行排序，并定义具体的排序规则，可以存在多种复杂的规则。\n排序方向的布尔值，只能传递布尔值True或False中的其中一个，如果传入True，表示逆序排序；如果传入False，表示正序排序。\n特别注意：\n我发现此函数与今天所学的其它函数都不同的地方在于，它并不是 返回了一个迭代器对象，而是返回的真正的序列对象。原序列的内容没有改变。\n测试：\nlstA=[('john','A',15),('jone','B',12),('dave','B',10)]\nprint(sorted(lstA,key=lambda x:x[2])) #这儿的排序函数是实时定义的匿名函数，只指明了按列表中元素——是元组对象的index为2的元素的值进行排序。\n运行结果：\n[('dave', 'B', 10), ('jone', 'B', 12), ('john', 'A', 15)]\n从运行结果中可以看出——\n此列表，共有三个元素，每个元素都是一个元组；\n每个元组都有三个元素，index值分别为0，1，2；\n而实时定义的排序关键字函数指明了x:x[2],按元组对象的index为2的元素的大小排序。\n于是结果是正确的排好的序，10<12<15\n现在我们对排序函数进行修改：\nlstA=[('john','A',15),('jone','B',12),('dave','B',10)]\nprint(sorted(lstA,key=lambda x:x[0])) #这儿的排序函数是实时定义的匿名函数，只指明了按列表中元素——是元组对象的index为0的元素的值进行排序。\n运行结果：\n[('dave', 'B', 10), ('john', 'A', 15), ('jone', 'B', 12)]\n4 reversed() 函数\n此函数反转一个序列中元素的先后顺序。\n格式：\n新的迭代器对象=reversed(序列对象)\n测试：\nstrA='孤荷凌寒参加工作后，每天在工作之外的空闲时间只能看着窗外的群山发呆，小山村没多少人，虽然自己也在农村长大，但孤荷凌寒并不玩牌，也性格内向。'\nitrA=reversed(strA)\nprint(itrA) #直接打印 迭代器，只能显示 内存地址\nlstA=list(itrA) #只能转换成list才能显示，不能直接还原成字符串了\nprint(lstA)\n运算结果：\n<reversed object at 0x000001DF1EFE4C88>\n['。', '向', '内', '格', '性', '也', '，', '牌', '玩', '不', '并', '寒', '凌', '荷', '孤', '但', '，', '大', '长', '村', '农', '在',\n'也', '己', '自', '然', '虽', '，', '人', '少', '多', '没', '村', '山', '小', '，', '呆', '发', '山', '群', '的', '外', '窗', '着', '看', '能', '只', '间', '时', '闲', '空', '的', '外', '之', '作', '工', '在', '天', '每', '，', '后', '作', '工', '加', '参', '寒', '\n凌', '荷', '孤']\n5 filter() 函数\n筛选一个序列，留下 序列中符合筛选条件的元素，返回新的迭代器：\n新的迭代器=filter(筛选函数,序列)\n筛选函数将有一个参数，对应于序列中的每一个元素。\n且筛选函数的返回对象只能是布尔对象即：True 或者 False\n在filter函数执行时，序列中的每一个元素都会被作为实参传递进筛选函数中进行运算，当序列中的一个元素传递进筛选函数后，如果筛选函数的运算结果是：True，则此元素会被认为符合筛选条件而通过筛选，被存放入新的迭代器对象中；如果筛选函数运算的结果是False，则此元素会被认为不符合筛选条件，就被忽略掉。\n测试：\nstrA='孤荷凌寒参加工作后，每天在工作之外的空闲时间只能看着窗外的群山发呆，小山村没多少人，虽然自己也在农村长大，但孤荷凌寒并不玩牌，也性格内向。'\ndef shaixuan(yuansu):\nstrKey='孤荷凌寒'\nif yuansu=='，':\nreturn True\nelif yuansu in strKey:\nreturn True\nelse:\nreturn False\nitrA=filter(shaixuan,strA)\nprint(itrA)\nlstA=list(itrA)\nprint(lstA)\n运算结果 ：\n<filter object at 0x000002457AB54C88>\n['孤', '荷', '凌', '寒', '，', '，', '，', '，', '孤', '荷', '凌', '寒', '，']\n6 map()函数\n将指定的一个或多个序列的每个元素都由作为指定的同一个函数的实参，然后由函数进行运算，并返回结果，然后将所有结果组合成一个新的迭代器对象返回。\n格式：\nmap(执行函数名 ，序列 [,序列2] [,序列3] [……])\n执行函数名是指要对序列的每个元素进行运算而事先已经定义好的函数的函数名。\n此函数要求至少要有一个形式参数，以便序列的每个元素都可以作为实参而传递进入函数体内进行运算。\n此函数在对序列的每个元素进行运算后都必须返回一个对象。\nmap()函数与filter()函数的不同之处在于，map()函数可以一次接受传入多个序列。\n传入n个序列则意味着map()函数的第一个形参——执行函数——必须要有n个形式参数，以便接收n个序列的各自的每个元素参与执行函数内部的运算。\n测试：\nstrA='读书是当时孤荷凌寒与外部世界沟通的唯一通道。'\nstrB='孤荷凌寒利用一切可以利用的休息时间学习。'\nstrC='当孤荷凌寒知道了世界上还有“电脑”这样的神奇的东西存在之后'\nstrD='孤荷凌寒准备自己学习英语，为的是有一天能够学习电脑。'\ndef function(yuansu):\nstrKey='孤荷凌寒'\nif yuansu=='，':\nreturn '逗号'\nelif yuansu in strKey:\nreturn yuansu\nelse:\nreturn '0'\nitrA=map(function,strA)\nprint(itrA)\nlstA=list(itrA)\nprint(lstA)\n运算结果：\n<map object at 0x000001D3E0FB4D30>\n['0', '0', '0', '0', '0', '孤', '荷', '凌', '寒', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']\n传入多个序列的测试：\nstrA='孤荷凌寒读书是当时与外部世界沟通的唯一通道。'\nstrB='孤荷凌寒利用一切可以利用的休息时间学习。'\nstrC='当孤荷凌寒知道了世界上还有“电脑”这样的神奇的东西存在之后'\nstrD='孤荷凌寒准备自己学习英语，为的是有一天能够学习电脑。'\ndef function(yuansu,ys2,ys3,ys4):\nstrKey='孤荷凌寒'\nif ((yuansu in strKey) and (ys2 in strKey) and (ys3 in strKey) and (ys4 in strKey)):\nreturn '命中'\nelse:\nreturn '0'\nitrA=map(function,strA,strB,strC,strD)\nprint(itrA)\nlstA=list(itrA)\nprint(lstA)\n运行结果：\n<map object at 0x00000227EFFE7BE0>\n['0', '命中', '命中', '命中', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']\n7 reduce()\nfrom functools import reduce\nnewobj=reduce(func,序列[,数值常量][……])\n此函数的用法，我的初步理解是：\n将传入的序列用函数 func 进行计算\n定义的func函数有几个形参就要有几个序列和常量传入\n此函数没有完全弄清楚，测试如下：\nfrom functools import reduce\ndef func(var,var2):\nreturn var + var2\nlstA=[1,2,3,4]\nlstB=[4,3,2,1]\nintA=reduce(func,lstA,10)\nprint(intA)\n运算结果：\n20\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/18DrDIY1HCirswLexdS9PDw\n  密码：liz8\nBilibili:\nhttps://www.bilibili.com/video/av35841103/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/138930894"},
{"url": "https://www.douban.com/note/697022410/", "title": "孤荷凌寒自学python第十天序列之字符串的常用方法", "article": "孤荷凌寒自学python第十天序列之字符串的常用方法\n（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）\nPython的字符串操作方法非常丰富，原生支持字符串的多种操作：\n1 查找子字符串\nstring.find(str,[beg=0],[end=len(string)])\n从字符串string中寻找str，可以指定从string的beg位置起开始找，直到string的end位置结束寻找。\n参数beg和end是可选参数，如果不指定那么，默认从string的最开头，即index为0的位置开始找，直到string整个字符串都找完。\nStr可以是单个字符，也可以是一个字符串。\n此方法会返回一个int类型的对象值。表示str这个字符串的第一个字符位于string字符串中的index值。\n例：\n>>> strLong='孤荷凌寒的QQ号是：578652607'\n>>> strShort='QQ'\n>>> print(strLong.find(strShort)) #从strLong中寻找strShort，没有指定从strLong的起始index和结束index中去找，则默认寻找strLong的全部字符。\n5\n#返回值5表示strShort代表的值’QQ’在strLong 的index值的第5位开始。\n>>> intTemp=strLong.find(strShort,4)  #从strLong中寻找strShort，这一次指定了从strLong的index值为4的字符开始往后寻找，直到最后。\n>>> print(intTemp)\n5\n#返回值仍然是5！！！表示strShort代表的值’QQ’在strLong 的index值的第5位开始。\n>>> intTemp=strLong.find(strShort,6)  #从strLong中寻找strShort，这一次指定了从strLong的index值为6的字符开始往后寻找，但因为从第6位字符开找是找不到的。\n>>> print(intTemp)\n-1\n#返回值是-1。表示是没有找到的。\n>>> intTemp=strLong.find(strShort,2,8)  #从strLong中寻找strShort，这一次指定了从strLong的index值为4的字符开始往后寻找，也指定了要一直找到strLong的index值为8的字符处为止。\n>>> print(intTemp)\n5\n#返回值仍然是5！！！表示strShort代表的值’QQ’在strLong 的index值的第5位开始。\n2 将列表等对象连接成字符串\nconnetString.join(obj)\n此处的连接成字符串是指将如列表等中的多个元素合并成一个字符串。而不是指将两个字符串连接起来。\nconnectString指的是连接字符或连接字符串，意思是要用哪个符号来间隔列表中的多个元素，使其作为连接字符将列表中的多个元素合并成一个字符串。\nObj是指如列表等需要合并其中元素为一个完整字符串的对象，可以为多种可以接受的对象。\n此方法将返回合并后的字符串对象。\n例：\n>>> strLst='孤荷凌寒小时候家里很穷。'\n>>> lstStr=list(strLst)\n>>> print(lstStr)\n['孤', '荷', '凌', '寒', '小', '时', '候', '家', '里', '很', '穷', '。']\n>>> strConnect=\"-\"\n>>> strConnect.join(lstStr) #特别注意这儿的写法，此join方法是由连接字符或连接字符串发出的方法。\n'孤-荷-凌-寒-小-时-候-家-里-很-穷-。'\n>>> strEnd=strConnect.join(lstStr)\n>>> print(strEnd)\n孤-荷-凌-寒-小-时-候-家-里-很-穷-。\n除了可以将列表的内容合并起来，其它非标准的序列也可以使用join方法。\n>>> objA='','我','是','自','学','Python','的','孤','荷','凌','寒',''\n>>> strConnect='=='\n>>> strResult=strConnect.join(objA)\n>>> print(strResult)\n==我==是==自==学==Python==的==孤==荷==凌==寒==\n3 将字符串的所有字符全部变成小写，只针对英文字符部分。\nstring.lower()\nstring是指要进行处理的字符串对象。\n此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。\n例:\n>>> strLs='孤荷凌寒的QQ号码是578652607'\n>>> strResult=strLs.lower()\n>>> print(strLs)\n孤荷凌寒的QQ号码是578652607 #strLs本身的值并没有改变\n>>> print(strResult)\n孤荷凌寒的qq号码是578652607\n4 将字符串的所有字符全部变成大写，只针对英文字符部分。\nstring.upper()\nstring是指要进行处理的字符串对象。\n此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。\n例:\n>>> strLs='孤荷凌寒的qq号码是578652607'\n>>> strResult=strLs.upper()\n>>> print(strLs)\n孤荷凌寒的qq号码是578652607 #strLs本身的值并没有改变\n>>> print(strResult)\n孤荷凌寒的QQ号码是578652607\n5 将字符串的所有英文字符进行大小写字母的反转，原来是大写字母的换成小写字母，原来是小写字母的，换成大写字母。\nstring.swapcase()\nstring是指要进行处理的字符串对象。\n此方法并不将改变string对象本身，而是返回一个改变后的新的字符串。\n例:\n>>> strLs='孤荷凌寒的qq号码是578652607,这是QQ号码哦。'\n>>> strResult=strLs.upper()\n>>> print(strLs)\n孤荷凌寒的qq号码是578652607,这是QQ号码哦。 #strLs本身的值并没有改变\n>>> print(strResult)\n孤荷凌寒的QQ号码是578652607,这是qq号码哦。\n6 查找并替换字符串中的子字符或子字符串\nString.replace(oldkey,newkey[,maxcount])\nString是指要进行查找并替换操作的长字符串。\n参数oldkey是指要查找的子字符串；\n参数newkey是指要将查找到的子字符串替换成的新字符串；\n可选参数maxcount是最多替换次数，是指如果在String中找到了多个oldkey，那么最多只替换前面maxcount个oldkey为newkey。\n此方法并不改变String的值，而是返回一个新的替换操作完成后的新字符串对象。\n例：\n>>> strLong='孤荷凌寒小时候家里很穷。孤荷凌寒小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。'\n>>> strOldKey='孤荷凌寒'\n>>> strNewKey='我'\n>>> strResult=strLong.replace(strOldKey,strNewKey,2) #本来有三个strOldKey,但只替换前面两个。\n>>> print(strLong) #strLong本身的值并没有改变\n孤荷凌寒小时候家里很穷。孤荷凌寒小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。\n>>> print(strResult)\n我小时候家里很穷。我小时候最大的心愿就是能够考个大学。但家里实在太穷，甚至没有钱上高中，孤荷凌寒后来初中毕业后只好读了中等师范学校。\n7 将字符串按指定的分隔符号或分隔字符串切割开并成为列表。\nString.split([strCutCharOrString][,maxcount=string.count(String)])\nString是指要被切割的字符串。\n可选参数 strCutCharOrString 表示分隔标识字符或字符串，如果 不指定，默认为空格。\n可选参数 maxcount 表示最多切割几次，如果不指定，则默认在String中找到多少个strCutCharOrString就切割几次。\n本方法返回一个列表对象。\n例：\n>>> strLong='1997年9月，孤荷凌寒进入中等师范学校学习，中等师范学校在过去是专门培养小学老师的学校，与中专一样，学制三年，可惜当时中等师范学校是不教习英语与计算机的，也没有高深的数学课程。'\n>>> strCutChar='，'\n>>> intCutCount=5 #在strLong中本来有六个strCutChar,即中文逗号有六个,但只在前面五个地方进行切割。\n>>> lstResult=strLong.split(strCutChar,intCutCount)\n>>> print(lstResult)\n['1997年9月', '孤荷凌寒进入中等师范学校学习', '中等师范学校在过去是专门培养小学老师的学校', '与中专一样', '学制三年', '可惜当时中等师范学校是不教习英语与计算机的，也没有高深的数学课程。']\n8 删除一个字符串首和尾指定的字符\nString.strip([charOrChars])\nString是指要被删除首和尾指定字符的字符串。\n可选参数charOrChars是指要删除的处于字符串String首和尾的哪个字符或哪些字符。\n如果不指定charOrChars参数，则默认删除掉字符串String首和尾的空格字符。\ncharOrChars参数可以只传入单个字符；\ncharOrChars参数也可以传入一个字符串，则会将charOrChars参数字符串中的每一个字符都执行一次操作，而不是将charOrChars参数字符串整体执行一次操作。\n此方法不对原字符串String的值进行任何修改，而是返回一个新的去除了首尾指定字符后的新字符串对象。\n例：\n>>> strTemp=' 孤 荷 凌 寒 '\n>>> strR=strTemp.strip() #strip方法没有指定可选参数，则默认去除strTemp首尾的空格字符，注意并不会删除strTemp字符串中间的空格\n>>> print(strTemp) #strTemp本身的值并没有被修改\n孤 荷 凌 寒 \n>>> print(strR)\n孤 荷 凌 寒\n>>> print('---' + strTemp + '---')  #在前后加上’---’方便看首尾空格是否还存在。 #strTemp本身的值并没有被修改\n--- 孤 荷 凌 寒 ---\n>>> print('---' + strR + '---') #在前后加上’---’方便看首尾空格是否还存在。\n---孤 荷 凌 寒---\n>>> strTemp='1234孤1荷2凌3寒4321'\n>>> strR2=strTemp.strip('1') #这一次strip方法传入了可选参数‘1’，是一个单个字符，则只会去除strTemp首尾的字符1，而不会删除strTemp字符串中间的字符1\n>>> strR3=strTemp.strip('1234') #这一次strip方法传入了可选参数‘1234’，是一个字符串，并不是说将删除strTemp字符串首尾的‘1234’，而是会分别删除strTemp字符串首尾的‘1’，‘2’，‘3’，‘4’，从下面的输出结果中就可以看到，虽然strTemp字符串尾巴的字符串是：’4321’，在此次执行strip方法时也被删除了。\n>>> print(strTemp)  #strTemp本身的值并没有被修改\n1234孤1荷2凌3寒4321\n>>> print(strR2)\n234孤1荷2凌3寒432\n>>> print(strR3)\n孤1荷2凌3寒\n9 指定一个对照表，将字符串中符合对照表中其中一行任意一个或多个关键字的字符更换成另一行中的关键字字符。\nString.translate(table[,deletechars])\nString是指要进行字符替换操作的字符串。\n参数table是指一张二维字符对照表。\n可选参数deletechars，用法不明。\n此操作没有对原字符串String的内容作任何修改，\n将返回一个替换完成后的新字符串对象。\n例：\n>>> strRow1='一二三四五六七八九十'\n>>> strRow2='壹贰叁肆伍陆柒捌玖拾'\n>>> tableTemp=str.maketrans(strRow1,strRow2)  #将此表格的两行合并成一张二维对照表\n>>> print(tableTemp) #打印时，显示的是对照字符的 编码 对照\n{19968: 22777, 20108: 36144, 19977: 21441, 22235: 32902, 20116: 20237, 20845: 38470, 19971: 26578, 20843: 25420, 20061: 29590, 21313: 25342}\n>>> strLong='孤荷凌寒的QQ号是五七八六五二六零七'\n>>> strR=strLong.translate(tableTemp)\n>>> print(strLong) #原字符串strLong的值没有发生变化\n孤荷凌寒的QQ号是五七八六五二六零七\n>>> print(strR)\n孤荷凌寒的QQ号是伍柒捌陆伍贰陆零柒\n——————————\n今天整理的学习笔记完成，最后例行说明下我的自学思路：\n根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。\n通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。\n于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。\n当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。\n于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。\n诚挚期待您的交流分享批评指点！\n欢迎联系我加入从零开始的自学联盟。\n这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。\n非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！\n根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。\n我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）\n链接：\nhttps://pan.baidu.com/s/1noO8wToR8OOmLvfQF0vvmw\n  密码：6kgy\nBilibili:\nhttps://www.bilibili.com/video/av35774836/\n \n喜马拉雅语音笔记：\nhttps://www.ximalaya.com/keji/19103006/137361136"},
{"url": "https://www.douban.com/note/541678899/", "title": "Python快速教程", "article": "作者：Vamei，严禁转载。\n\n这个Python教程写于2012年，现在把目录贴在豆瓣日记里。当时的一位朋友问我怎么能快速地掌握Python。 我想Python包含的内容很多，加上各种标准库，拓展库，乱花渐欲迷人眼，就想写一个快速的，类似于w3cschool风格的Python教程，一方面保持言语的简洁，另一方面循序渐进，尽量让没有背景的读者可以从基础开始学习。另外，我在每一篇中专注于一个小的概念，希望让人可以在闲暇时很快读完。 \n\n小提醒：\n1. 教程将专注于Python基础，语法基于Python 2.7 (我会提醒Python 3.x中有变化的地方，以方便读者适应3.X的情况)。测试环境为Linux, 将不会使用到标准库之外的模块。标准库的一些包不适用于windows平台。如果文中的程序无法在你的平台上运行，欢迎讨论。 \n2. 我将专注于Python的主干，以便读者能以最快时间对Python形成概念。 \n3. Linux命令行将以 $ 开始，比如 $ls, $python \n4. Python命令行将以 >>> 开始，比如 >>>print 'Hello World!' \n5. 注释会以 # 开始 \n6. 将教程中的命令敲到Python中看看效果。 \n7. 看过教程之后，可以进行一些练习。 \n练习，练习\n\n那么，下面就开始吧。\n\n=============================================== \n下面将介绍Python语法，分为基础、进阶和深入三个部分。在即将开始的基础部分里，将介绍Python语法的基础，并用相对生动的方式讲解面向对象的基本概念。\n基础\n\nPython基础01 Hello World! \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/28/2521650.html\n \n\nPython基础02 基本数据类型 \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/28/2522385.html\n \n\nPython基础03 序列 \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/28/2522677.html\n \n\nPython基础04 运算 \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/29/2524376.html\n \n\nPython基础05 缩进和选择 \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/29/2524706.html\n \n\nPython基础06 循环 \n\nhttp://www.cnblogs.com/vamei/archive/2012/05/30/2526357.html\n \n\nPython基础07 函数 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/01/2529500.html\n \n\nPython基础08 面向对象的基本概念 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/02/2531515.html\n \n\nPython基础09 面向对象的进一步拓展 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/02/2532018.html\n \n\nPython基础10 反过头来看看 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/02/2532274.html\n \n\n--------------------------------------------------------------------------------------------- \n在进阶部分，将讲解Python编程中常用的一些数据结构、功能和特殊要点。基础部分的语法是每次编程都需要的，而进阶部分有时可能并不需要。但鉴于它们在编程中出现频率很高，所以也建议把进阶部分看做编程的必备武器。\n进阶\n\nPython进阶01 词典 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/06/2537436.html\n \n\nPython进阶02 文本文件的输入输出 \n\nhttp://www.cnblogs.com/vamei/archive/2012/06/06/2537868.html\n \n\nPython进阶03 模块 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/03/2574436.html\n \n\nPython进阶04 函数的参数传递 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/08/2581264.html\n \n\nPython进阶05 循环设计 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/09/2582435.html\n \n\nPython进阶06 循环对象 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/09/2582499.html\n \n\nPython进阶07 函数对象 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/10/2582772.html\n \n\nPython进阶08 错误处理 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/10/2582787.html\n \n\nPython进阶09 动态类型 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/10/2582795.html\n \n\n--------------------------------------------------------------------------------------------- \n\n在下面的部分中，我想深入讨论Python的体系。Python的语法很丰富，但这些语法都是建立在一个很简单的对象模型基础上的。这一部分的内容并不是使用Python所必须的，可以跳过。但如果你不满足于一个Python使用者的定位，从事一些Python高阶的开发，你会希望对这一对象模型有进一步的了解。此外，我也会在这一部分补充说明前面遗留的一些话题。 \n深入\n\nPython深入01 特殊方法与多范式 \n\nhttp://www.cnblogs.com/vamei/archive/2012/11/19/2772441.html\n \n\nPython深入02 上下文管理器 \n\nhttp://www.cnblogs.com/vamei/archive/2012/11/23/2772445.html\n \n\nPython深入03 对象的属性 \n\nhttp://www.cnblogs.com/vamei/archive/2012/12/11/2772448.html\n \n\nPython深入04 闭包 \n\nhttp://www.cnblogs.com/vamei/archive/2012/12/15/2772451.html\n \n\nPython深入05 装饰器 \n\nhttp://www.cnblogs.com/vamei/archive/2013/02/16/2820212.html\n \n\nPython深入06 内存管理原理 \n\nhttp://www.cnblogs.com/vamei/p/3232088.html\n \n\n--------------------------------------------------------------------------------------------- \n这一部分补充一些教程中没有涉及的部分，以及Python的简要历史。\n补充\n\nPython补充01 序列的方法 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/19/2599940.html\n \n\nPython补充02 Python小技巧 \n\nhttp://www.cnblogs.com/vamei/archive/2012/11/06/2755503.html\n \n\nPython补充03 Python内置函数清单 \n\nhttp://www.cnblogs.com/vamei/archive/2012/11/09/2762224.html\n \n\nPython补充04 Python简史 \n\nhttp://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html\n \n\nPython补充05 字符串格式化 (%操作符) \n\nhttp://www.cnblogs.com/vamei/archive/2013/03/12/2954938.html\n \n\nPython补充06 Python之道 \n\nhttp://www.cnblogs.com/vamei/p/3138446.html\n \n\n--------------------------------------------------------------------------------------------- \n在Python的基础之后，Python标准库自然成为下一个挑战。Python标准库的重要性在于： \n1） 它是Python的一部分。 \n2） Python的哲学是一个问题只有一个最好的解决方法，这些标准库就为相应的问题提供了一个标准的解决方案。 \n\nPython标准库的学习需要一定的操作系统的基础知识。我之前读到的Python标准库的相关教程中，都有一个共同的问题，就是假设你已经对操作系统和网络基础有所了解。当然，如果是在系统方面经验丰富就好，但是如果很生疏，那么学习Python标准库就有很大的困难。然而，全面地学习系统知识需要大量的精力和时间。出于此，我也在Linux小组增加一个Linux系统相关的贴，主要用于讨论Linux的基本概念和体系。这些概念和体系可以构成一个基本的框架，了解之后，可以比较从容地学习Python标准库。你也可以选择继续读标准库，直到需要补充这些知识的时候，根据Python标准库中给出的链接，来阅读这些系统相关的文章。 \n\nhttp://www.douban.com/group/topic/32510823/\n \n标准库\n\nPython标准库——走马观花 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/18/2597212.html\n \n\nPython标准库的学习准备 \n\nhttp://www.cnblogs.com/vamei/archive/2012/07/23/2605345.html\n \n\nPython标准库01 正则表达式 (re包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/08/31/2661870.html\n \n\nPython标准库02 时间与日期 (time, datetime包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/09/03/2669426.html\n \n\nPython标准库03 路径与文件 (os.path包, glob包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/09/05/2671198.html\n \n\nPython标准库04 文件管理 (部分os包，shutil包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/09/14/2684775.html\n \n\nPython标准库05 存储对象 (pickle包，cPickle包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/09/15/2684781.html\n \n\nPython标准库06 子进程 (subprocess包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/09/23/2698014.html\n \n\nPython标准库07 信号 (signal包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/06/2712683.html\n \n\nPython标准库08 多线程与同步 (threading包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/11/2720042.html\n \n\nPython标准库09 进程信息 (部分os包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/12/2721016.html\n \n\nPython标准库10 多进程初步 (multiprocessing包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/12/2721484.html\n \n\nPython标准库11 多进程探索 (multiprocessing包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/13/2722254.html\n \n\nPython标准库12 数学与随机数 (math包，random包) \n\nhttp://www.cnblogs.com/vamei/archive/2012/10/26/2741702.html\n \n\nPython标准库13 循环器 (itertools) \n\nhttp://www.cnblogs.com/vamei/p/3174796.html\n \n\nPython标准库14 数据库 (sqlite3) \n\nhttp://www.cnblogs.com/vamei/p/3794388.html\n \n\n--------------------------------------------------------------------------------------------- \nPython在网络方面有很多应用，无论是作为服务器端提供HTTP服务（比如豆瓣），还是作为客户端抓取网页。在网络框架方面，Python也有多种选择，其中用得最广的是Django。Django内部提供了建服务器所需的各种功能，所以可以快速的一站式开发。下面部分为Django的一个简短入门教程。\nDjango\n\n被解放的姜戈01 初试天涯 \n\nhttp://www.cnblogs.com/vamei/p/3528878.html\n \n\n被解放的姜戈02 庄园疑云 \n\nhttp://www.cnblogs.com/vamei/p/3531740.html\n \n\n被解放的姜戈03 所谓佳人 \n\nhttp://www.cnblogs.com/vamei/p/3538183.html\n \n\n被解放的姜戈04 各取所需 \n\nhttp://www.cnblogs.com/vamei/p/3546090.html\n \n\n被解放的姜戈05 黑面管家 \n\nhttp://www.cnblogs.com/vamei/p/3548762.html\n \n\n被解放的姜戈06 假作真时 \n\nhttp://www.cnblogs.com/vamei/p/3550951.html\n \n\n被解放的姜戈07 马不停蹄 \n\nhttp://www.cnblogs.com/vamei/p/3578718.html\n \n\n-------------------------------------------------------------------- \n\nPython快速教程 尾声 \n\nhttp://www.cnblogs.com/vamei/p/3603046.html\n \n\n================================================= \n参考书以及介绍 \n见豆列: \nhttp://book.douban.com/doulist/1619790/\n \n================================================="}
]